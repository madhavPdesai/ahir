//
// Copyright (C) 2010-: Madhav P. Desai
// All Rights Reserved.
//  
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal with the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimers.
//  * Redistributions in binary form must reproduce the above
//    copyright notice, this list of conditions and the following
//    disclaimers in the documentation and/or other materials provided
//    with the distribution.
//  * Neither the names of the AHIR Team, the Indian Institute of
//    Technology Bombay, nor the names of its contributors may be used
//    to endorse or promote products derived from this Software
//    without specific prior written permission.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR
// ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.
#ifndef _Aa_Expression__
#define _Aa_Expression__

#include <AaIncludes.h>
#include <AaEnums.h>
#include <AaUtil.h>
#include <AaRoot.h>
#include <AaScope.h>
#include <AaType.h>
#include <AaValue.h>


//**************************************** EXPRESSION ****************************************
class AaStorageObject;
class AaMemorySpace;
class AaPipeObject;
class AaStatement;
class AaAssignmentStatement;
class AaDoWhileStatement;
class AaPhiStatement;
class AaSimpleObjectReference;
class AaModule;
class AaExpression: public AaRoot
{
	// the containing scope of this expression
	AaScope* _scope;
	bool _coalesce_flag;
	bool _is_target;
	bool _does_pipe_access;
	bool _is_malformed;
	bool _is_intermediate;


	AaExpression* _guard_expression;
	bool _guard_complement;


	protected:
	
	// type of the expression
	AaType* _type;

	// expressions which are targets of this
	// expression.
	set<AaExpression*> _targets;

	// coalesce flag, used during memory space
	// identification..
	void Set_Coalesce_Flag(bool v) { _coalesce_flag = v;}
	bool Get_Coalesce_Flag() {return(_coalesce_flag);}


	int _phi_source_index;


	// expression is handled in a different
	// way if it is part of a do-while statement.
	// or a pipelined module.
	AaStatement* _pipeline_parent;

	// the expression, when evaluated at run
	// time, can produce a value.  In the following
	// set, we keep all the storage objects whose
	// addresses can be generated by this expression.
	// we keep one representative of all such 
	// objects (others are connected to this representative
	// in AaProgram::_storage_dependency_graph).
	AaStorageObject* _addressed_object_representative;


	// if this expression is a target through an
	// an assignment statement, then rhs_source
	// is the expression which leads to this..
	set<AaExpression*> _rhs_sources;

	// statement with which it is associated,
	// either as a source or as a target.
	AaStatement* _associated_statement;

	bool _already_evaluated;


	void Replace_Field_Expression(AaExpression** eptr, AaExpression* used_expr, AaAssignmentStatement* replacement);

	int _buffering;
	public:

	AaValue* _expression_value;

	virtual void Set_Buffering(int d) {_buffering = d;}
	virtual int Get_Buffering() {return(_buffering);}
 	virtual void Print_Buffering(ostream& ofile);
	virtual void Write_VC_Output_Buffering(string dpe_name, string tgt_name, ostream& ofile);
	virtual void Write_VC_Input_Buffering(string dpe_name, string src_name, ostream& ofile)
 	{
	}

	virtual void Set_Phi_Source_Index(int v) {_phi_source_index = v;}
	int Get_Phi_Source_Index() {return(_phi_source_index);}

	virtual void Write_VC_Phi_Start_Dependency(ostream& ofile);

	virtual void Set_Guarded_Expression(AaExpression* expr) {assert(0);}
	virtual AaExpression* Get_Guarded_Expression() {return(NULL);}
	virtual void Set_Guarded_Statement(AaExpression* stmt) {assert(0);}
	virtual AaStatement* Get_Guarded_Statement() {return(NULL);}

	AaPhiStatement* Get_Associated_Phi_Statement();

	virtual AaScope* Get_Scope() { return(this->_scope);}
	virtual AaModule* Get_Module();

	AaExpression(AaScope* scope_tpr);
	~AaExpression();
	virtual string Kind() {return("AaExpression");}

	virtual bool Has_No_Registered_Update() {return(false);}

	virtual void Set_Associated_Statement(AaStatement* stmt)
	{
		_associated_statement = stmt;
	}
	AaStatement* Get_Associated_Statement()
	{
		return(_associated_statement);
	}

	virtual bool Is_Trivial() {return(false);}
	virtual bool Is_Flow_Through();


	virtual bool Is_Signal_Read() {return(false);}
	virtual bool Is_Indirect_Signal_Read() {return(false);}

	virtual int Get_Delay();

	void Set_Is_Intermediate(bool v) 
	{
		_is_intermediate = v; 
	}
	bool Get_Is_Intermediate()  {return(_is_intermediate);}
	// malformed if something wrong.. e.g. unknown memory space in pointer deref.
	void Set_Is_Malformed(bool v) { _is_malformed = v;}
	bool Get_Is_Malformed() {return(_is_malformed);}

	virtual void Set_Pipeline_Parent(AaStatement* dws) {_pipeline_parent = dws;}
	AaStatement* Get_Pipeline_Parent() {return(_pipeline_parent);}

	void Set_Does_Pipe_Access(bool v) { _does_pipe_access = v; }
	bool Get_Does_Pipe_Access() { return(_does_pipe_access); }

	void Set_Is_Target(bool v) {_is_target = v;}
	bool Get_Is_Target() {return(_is_target);}

	virtual bool Is_Foreign_Store() {return false;}
	virtual bool Is_Foreign_Load() {return false;}

	void Add_RHS_Source(AaExpression* src) { _rhs_sources.insert(src); }
	bool Is_RHS_Source(AaExpression* src) { return(_rhs_sources.find(src) != _rhs_sources.end()); }

	virtual bool Set_Addressed_Object_Representative(AaStorageObject* obj);
	AaStorageObject* Get_Addressed_Object_Representative() 
	{
		return(this->_addressed_object_representative);
	}

	virtual void Propagate_Addressed_Object_Representative(AaStorageObject* obj, AaRoot* from_expr);

	virtual void Set_Type(AaType* t);
	virtual AaType* Get_Type() {return(this->_type);}
	virtual AaValue* Get_Expression_Value() {return(this->_expression_value);}

	virtual void Map_Source_References(set<AaRoot*>& source_objects) { assert(0); }
	virtual void Map_Source_References_As_Target(set<AaRoot*>& source_objects) { assert(0); }
	virtual bool Is_Expression() {return(true); }
	virtual bool Is_Object_Reference() {return(false);}
	virtual bool Is_Constant_Literal_Reference() {return(false);}

        virtual string C_Reference_String() {return (this->Get_VC_Name());}
        virtual void PrintC( ofstream& ofile) {assert(0);}
        virtual void PrintC_Declaration(ofstream& ofile);

	virtual AaRoot* Get_Root_Object() {return(NULL);}
	virtual void Update_Type() {};

	virtual void Add_Target(AaExpression* expr) {this->_targets.insert(expr);}
	virtual void Remove_Target(AaExpression* expr) {this->_targets.erase(expr);}

	virtual int Get_Number_Of_Targets() {return (this->_targets.size());}

	virtual string Get_C_Name() {return(this->Get_VC_Name());}
	virtual string Get_VC_Name();

	virtual void Write_VC_Control_Path( ostream& ofile);
	virtual void Write_VC_Control_Path_As_Target( ostream& ofile) 
	{
		this->Write_VC_Control_Path(ofile);
	}

	void Write_VC_WAR_Dependencies(bool pipeline_flag, set<AaRoot*>& visited_elements, ostream& ofile);
	virtual bool Is_Load() {return(false);}
	virtual bool Is_Store() {return(false);}
	virtual void Write_VC_Links_Optimized(string hier_id, ostream& ofile) {}
	virtual void Write_VC_Links_As_Target_Optimized(string hier_id, ostream& ofile) {}

	virtual void Write_VC_Control_Path_Optimized(bool pipeline_flag, 
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile)
	{
	}
	virtual void Write_VC_Control_Path_As_Target_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile)
	{
	}

	virtual void Write_VC_Constant_Wire_Declarations(ostream& ofile) {}
	virtual void Write_VC_Wire_Declarations(bool skip_immediate, ostream& ofile) {}
	virtual void Write_VC_Wire_Declarations_As_Target(ostream& ofile) {}
	virtual void Write_VC_Datapath_Instances_As_Target( ostream& ofile, AaExpression* source) {}
	virtual void Write_VC_Datapath_Instances(AaExpression* target,  ostream& ofile) {}
	virtual void Write_VC_Links(string hier_id, ostream& ofile) {}
	virtual void Write_VC_Links_As_Target(string hier_id, ostream& ofile) {}
	virtual string Get_VC_Wire_Name()
	{
		return(this->Get_VC_Name() + "_wire");
	}

	virtual string Get_VC_Start_Region_Name()
	{
		return(this->Get_VC_Name() + "_start");
	}

	virtual string Get_VC_Request_Region_Name()
	{
		return(this->Get_VC_Name() + "_request");
	} 

	virtual string Get_VC_Complete_Region_Name()
	{
		return(this->Get_VC_Name() + "_complete");
	}


	virtual string Get_VC_Constant_Name()
	{
		return(this->Get_VC_Wire_Name() + "_constant");
	}

	virtual string Get_VC_Driver_Name()
	{
		if(this->Is_Constant())
			return(this->Get_VC_Constant_Name());
		else
			return(this->Get_VC_Wire_Name());
	}

	virtual string Get_VC_Resized_Base_Address_Name()
	{
		return(this->Get_VC_Name() + "_resized_base_address");
	}

	virtual string Get_VC_Receiver_Name()
	{
		return(this->Get_VC_Wire_Name());
	}

	virtual string Get_VC_Datapath_Instance_Name()
	{
		return(this->Get_VC_Name() +  "_inst");
	}

	virtual void Get_Leaf_Expression_Set(set<AaExpression*>& leaf_expression_set)
	{
		assert(0);
	}

	virtual string Get_VC_Guard_String();

	virtual bool Is_Constant() {return(this->_expression_value != NULL);}

	virtual bool Is_Implicit_Variable_Reference() {return(false);}
	virtual bool Is_Interface_Object_Reference() {return(false);}
	virtual bool Is_Volatile_Function_Call() {return(false);}

	virtual bool Is_Implicit_Object() {return(false);}

	virtual void Evaluate() {if(!_already_evaluated) _already_evaluated = true;};
	virtual void Assign_Expression_Value(AaValue* expr_value);

	virtual bool Scalar_Types_Only() { return(true);}

	set<AaExpression*>& Get_Targets() {return _targets; }

	virtual int Get_VC_Memory_Space_Index() {return (-1);}  // default.. no memory space

	// return true if the only place this is (eventually) used
	// is an address-of expression
	bool Used_Only_In_Address_Of_Expression();

	virtual void Set_Guard_Expression(AaExpression* expr);
	virtual void Set_Guard_Complement(bool v);

	virtual AaExpression* Get_Guard_Expression();
	virtual bool Get_Guard_Complement();

	virtual void Write_VC_Guard_Dependency(bool pipeline_flag, set<AaRoot*>& visited_elements, ostream& ofile);
	virtual void Write_VC_Guard_Forward_Dependency(AaRoot* guard_expr_root, set<AaRoot*>& visited_elements, ostream& ofile);
	virtual void Write_VC_Guard_Backward_Dependency(AaExpression* expr, set<AaRoot*>& visited_elements, ostream& ofile);

	virtual bool  Is_NOP() {return(false);}
	void Write_VC_RAW_Release_Dependencies(AaExpression* expr, set<AaRoot*>& visited_elements);
	void Identify_Non_Trivial_Predecessors(set<AaRoot*>& non_triv_preds, set<AaRoot*>& visited_elements)
	{
		assert(0);
	}
	virtual void Get_Non_Trivial_Source_References(set<AaRoot*>& tgt_set, set<AaRoot*>& visited_elements);

	virtual string Get_VC_Reenable_Update_Transition_Name(set<AaRoot*>& visited_elements) {

		if(this->Is_Constant())
			return("$entry");
		else
			return(this->Get_VC_Update_Start_Transition_Name());    

	}

	virtual string Get_VC_Reenable_Sample_Transition_Name(set<AaRoot*>& visited_elements) {
		if(this->Is_Constant())
			return("$entry");
		else
			return(this->Get_VC_Sample_Start_Transition_Name());    
	}


	virtual void Replace_Uses_By(AaExpression* used_expr, AaAssignmentStatement* replacement) {assert(0);}
	void Replace_Uses_By(AaExpression* used_expr, AaExpression* replacement);

	virtual string Get_Name() {return(this->Get_VC_Name());}


	virtual bool Is_Part_Of_Pipeline() {return(this->_pipeline_parent != NULL);}
	virtual bool Is_Part_Of_Fullrate_Pipeline();
	virtual bool Is_Part_Of_Operator_Module();

	virtual void Collect_Root_Sources(set<AaRoot*>& root_set) {if(!this->Is_Constant()) root_set.insert(this);}
	virtual void Write_VC_Update_Reenables(AaRoot* reenabling_agent, 
							string ctrans, bool bypass_if_true,  set<AaRoot*>& visited_elements, ostream& ofile);


	virtual bool Is_Part_Of_Pipelined_Module(); // TODO: return true if in pipelined module.


	virtual void Update_Guard_Adjacency(map<AaRoot*, vector< pair<AaRoot*, int> > >& adjacency_map, set<AaRoot*>& visited_elements);
	virtual AaRoot* Get_Object() { assert(0); }

	virtual bool Update_Protocol_Has_Delay(set<AaRoot*>& visited_elements) {return(true);}

	virtual void Mark_As_Visited(set<AaRoot*>& visited_elements)
	{
		visited_elements.insert(this);
	}

	//
	// used in root address calculation.
	// 
	virtual void
		Update_Reenable_Points_And_Producer_Delay_Status(set<string>& en_points, 
					set<string>& en_unmarked_points, map<string,bool>& en_bypass_flags, 
													set<AaRoot*>& visited_elements);


	virtual void Write_Forward_Dependency_From_Roots(string dependent_transition, 
								int64_t to_index, // to prevent cycles!
									set<AaRoot*>& visited_elements,
										ostream& ofile);
	
	virtual void Check_Volatile_Inconsistency();
	virtual void Check_Volatile_Inconsistency(AaStatement* stmt);

	virtual void Write_VC_Pipelined_Module_Enable_Joins(set<AaRoot*>& visited_elements, ostream& ofile)
	{
		// default.. do nothing.
	}

	virtual int Get_Existing_Buffering() {return(0);}
	virtual AaMemorySpace* Get_VC_Memory_Space();

	virtual bool Is_Pipe_Read()  {return(false);}
	virtual bool Is_Pipe_Write() {return(false);}

	virtual bool Can_Be_Combinationalized() {return(false);}
	virtual bool Is_Opaque_Function_Call_Expression() {return(false);}
	virtual bool Get_Is_Volatile() {return(false);}

};


// Object Reference: base class for
// references to objects such as a, a[i], ./a[i][j]
// etc.
class AaObjectReference: public AaExpression
{

	protected:


		// the original string which was 
		// in the source file.
		string _object_ref_string;

		// make it more interesting for second pass
		// fixup

		// 0 means start searching from here
		// 1 means start searching in parent of this
		// and so on
		unsigned int _search_ancestor_level; 

		// if vector is (a b), this means that
		// look for child from search start point/a/b
		vector<string> _hier_ids;

		// root object.
		string _object_root_name;

		// the object to which this reference points!
		// figure it out in the second pass.
		// for an object reference which defines
		// an implicit variable, _object points
		// to the statement which defined it.
		AaRoot* _object;

		bool _is_dereferenced;

	public:

		AaObjectReference(AaScope* scope_tpr, string object_ref_string);
		AaObjectReference(AaScope* scope_tpr, AaAssignmentStatement* root_obj);

		~AaObjectReference();
		virtual void Print(ostream& ofile);
		virtual string Get_Object_Ref_String() {return(this->_object_ref_string);}
		AaType* Get_Address_Type(vector<AaExpression*>* );

		virtual void Set_Object(AaRoot* obj) {this->_object = obj;}
		virtual AaRoot* Get_Object() { return(this->_object);}
		AaType* Get_Object_Type();
		virtual int Evaluate(vector<AaExpression*>* indices, vector<int>* scale_factors, vector<int>* shift_factors);
		virtual void Add_Hier_Id(string hier_id) {this->_hier_ids.push_back(hier_id);}
		virtual void Set_Object_Root_Name(string orn) {this->_object_root_name = orn; }
		virtual string Get_Object_Root_Name() {return(this->_object_root_name);}
		virtual void Set_Search_Ancestor_Level(unsigned int sal) {this->_search_ancestor_level = sal;}
		virtual unsigned int Get_Search_Ancestor_Level() {return(this->_search_ancestor_level);}
		virtual bool Is_Hierarchical_Reference() 
		{
			return((this->_hier_ids.size() > 0) || (this->_search_ancestor_level > 0));
		}
		virtual string Kind() {return("AaObjectReference");}
		virtual void Map_Source_References(set<AaRoot*>& source_objects); // important
		virtual void Map_Source_References_As_Target(set<AaRoot*>& source_objects)
		{
		}

		void Update_Globally_Accessed_Objects(AaStorageObject* sobj);

		virtual void Add_Target_Reference(AaRoot* referrer); 
		virtual void Add_Source_Reference(AaRoot* referrer);
        	virtual void PrintC( ofstream& ofile) {assert(0);}
		virtual bool Is_Object_Reference() {return(true);}

		virtual void Evaluate();
		void PrintAddressOfC(ofstream& ofile) {}

		virtual void Propagate_Addressed_Object_Representative(AaStorageObject* obj, AaRoot* from_expr);

		virtual void Set_Associated_Statement(AaStatement* stmt)
		{
			_associated_statement = stmt;
		}



		// common operations across loads/stores.
		void Write_VC_Load_Control_Path(vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);

		void Write_VC_Store_Control_Path( vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);

		void Write_VC_Load_Store_Constants(vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);

		void Write_VC_Load_Store_Wires(vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);


		void Write_VC_Load_Data_Path(vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				AaExpression* target,
				ostream& ofile);

		void Write_VC_Store_Data_Path(vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				AaExpression* source,
				ostream& ofile);

		void Write_VC_Load_Links(string hier_id,
				vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);

		void Write_VC_Store_Links(string hier_id,
				vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);


		void Write_VC_Load_Store_Control_Path(vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				string read_or_write,
				ostream& ofile);


		void Write_VC_Load_Store_Data_Path(vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				AaExpression* data_expression,
				string read_or_write,  
				ostream& ofile);

		void Write_VC_Load_Store_Links( string hier_id,
				string read_or_write,
				vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);



		void Write_VC_Address_Calculation_Constants(vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);
		void Write_VC_Address_Calculation_Wires(vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);
		void Write_VC_Address_Calculation_Control_Path(vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);
		void Write_VC_Address_Calculation_Data_Path(vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);


		void Write_VC_Root_Address_Calculation_Constants(vector<AaExpression*>* indices,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);
		void Write_VC_Root_Address_Calculation_Wires(vector<AaExpression*>* indices,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);

		void Write_VC_Address_Calculation_Links(string hier_id,
				vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);


		void Write_VC_Root_Address_Calculation_Control_Path(vector<AaExpression*>* indices,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);
		void Write_VC_Root_Address_Calculation_Links(string hier_id,
				vector<AaExpression*>* indices,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);



		void Write_VC_Root_Address_Calculation_Data_Path(vector<AaExpression*>* indices,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);


		virtual string Get_VC_Memory_Space_Name();
		virtual int Get_VC_Memory_Space_Index();

		virtual int Get_Base_Address();
		virtual int Get_Address_Width();
		virtual int Get_Word_Size();


		virtual string Get_VC_Base_Address_Name();
		virtual string Get_VC_Word_Address_Name(int idx);

		virtual string Get_VC_Offset_Name();
		virtual string Get_VC_Offset_Constant_Part_Name();
		virtual string Get_VC_Non_Constant_Index_Sum_Name();
		virtual string Get_VC_Root_Address_Name();
		virtual string Get_VC_Word_Offset_Name(int idx);
		virtual string Get_VC_Offset_Scale_Factor_Name(int idx);
		virtual AaType* Get_Base_Address_Type();
		virtual int Get_Access_Width();
		virtual void Assign_Expression_Value(AaValue* expr_value);


		virtual bool Is_Load();
		virtual bool Is_Store();



		// control-path optimizations.
		void Write_VC_Load_Control_Path_Optimized(bool pipeline_flag, set<AaRoot*>& visited_elements,
				map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
				map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
				vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				AaRoot* barrier,
				ostream& ofile);

		void Write_VC_Store_Control_Path_Optimized(bool pipeline_flag, set<AaRoot*>& visited_elements,
				map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
				map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
				vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				AaRoot* barrier,
				ostream& ofile);

		void Write_VC_Load_Store_Control_Path_Optimized(bool pipeline_flag, set<AaRoot*>& visited_elements,
				map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
				map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
				vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				string read_or_write,
				AaRoot* barrier,
				ostream& ofile);

		void Write_VC_Load_Links_Optimized(string hier_id,
				vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);

		void Write_VC_Store_Links_Optimized(string hier_id,
				vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);


		void Write_VC_Load_Store_Links_Optimized( string hier_id,
				string read_or_write,
				vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);

		void Write_VC_Address_Calculation_Control_Path_Optimized(bool pipeline_flag, set<AaRoot*>& visited_elements,
				map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
				map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
				vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				AaRoot* barrier,
				set<string>& active_reenable_points,
				set<string>& active_unmarked_reenable_points,
				map<string,bool>& active_reenable_bypass_flags,
				ostream& ofile);

		void Write_VC_Address_Calculation_Links_Optimized(string hier_id,
				vector<AaExpression*>* address_expressions,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);


		void Write_VC_Root_Address_Calculation_Control_Path_Optimized(bool pipeline_flag, set<AaRoot*>& visited_elements,
				map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
				map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
				vector<AaExpression*>* indices,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				set<string>& active_reenable_points,
				set<string>& active_unmarked_reenable_points,
				map<string,bool>& active_reenable_bypass_flags,
				AaRoot* barrier,
				ostream& ofile);
		void Write_VC_Root_Address_Calculation_Links_Optimized(string hier_id,
				vector<AaExpression*>* indices,
				vector<int>* scale_factors,
				vector<int>* shift_factors,
				ostream& ofile);

		virtual bool Scalar_Types_Only() { return(false);}
		bool Get_Is_Dereferenced() {return(_is_dereferenced);}
		void Set_Is_Dereferenced(bool v);

		virtual string Get_VC_Base_Address_Update_Reenable_Transition(set<AaRoot*>& visited_elements)
		{
			assert(0);
		}
		virtual string Get_VC_Base_Address_Update_Unmarked_Reenable_Transition(set<AaRoot*>& visited_elements)
		{
			assert(0);
		}

	virtual bool Writes_To_Memory_Space(AaMemorySpace* ms);

	virtual int Get_Delay();
	virtual bool Can_Be_Combinationalized();

};

// simple reference to a constant string (must be integer or real scalar or array)
class AaConstantLiteralReference: public AaObjectReference
{
	vector<string> _literals;
	bool _scalar_flag;
	public:
	AaConstantLiteralReference(AaScope* scope_tpr, 
			string literal_string,  
			vector<string>& literals);
	AaConstantLiteralReference(AaScope* scope, int param_val);
	~AaConstantLiteralReference();
	vector<string>& Get_Literals() {return(_literals);}
	void Set_Scalar_Flag(bool v) {_scalar_flag = v;}
	bool Get_Scalar_Flag() {return(_scalar_flag);}

	virtual string Kind() {return("AaConstantLiteralReference");}
	virtual void Map_Source_References(set<AaRoot*>& source_objects) {} // do nothing
	virtual void PrintC( ofstream& ofile);
	virtual void Write_VC_Control_Path( ostream& ofile);


	virtual bool Is_Constant_Literal_Reference() {return(true);}
	virtual void Get_Leaf_Expression_Set(set<AaExpression*>& leaf_expression_set)
	{
		leaf_expression_set.insert(this);
	}

	virtual void Write_VC_Constant_Wire_Declarations(ostream& ofile);
	virtual void Evaluate();

	virtual void Set_Associated_Statement(AaStatement* stmt)
	{
		_associated_statement = stmt;
	}
	virtual void Collect_Root_Sources(set<AaRoot*>& root_set) {};
	virtual string Get_VC_Name() {return("konst_" + Int64ToStr(this->Get_Index()));}
	virtual bool Can_Be_Combinationalized() {return(true);}

};

// simple reference (no array indices)
class AaSimpleObjectReference: public AaObjectReference
{

	set<AaStorageObject*> _addressed_objects;
	AaStatement* _guarded_statement;
	AaExpression* _guarded_expression;

	bool _in_collect_roots_stack;
	public:

	virtual void Set_Guarded_Statement(AaStatement* stmt) {_guarded_statement = stmt;}
	virtual AaStatement* Get_Guarded_Statement() {return(_guarded_statement);}

	virtual void Set_Guarded_Expression(AaExpression* expr) {_guarded_expression = expr;}
	virtual AaExpression* Get_Guarded_Expression() {return(_guarded_expression);}

	virtual bool Is_Pipe_Read();
	virtual bool Is_Pipe_Write();
	AaSimpleObjectReference(AaScope* scope_tpr, string object_ref_string);
	AaSimpleObjectReference(AaScope* scope_tpr, AaAssignmentStatement* root_object);

	~AaSimpleObjectReference();
	virtual string Kind() {return("AaSimpleObjectReference");}
	virtual void Set_Object(AaRoot* obj);
	virtual void Print(ostream& ofile);

        virtual string C_Reference_String();

	virtual void PrintC_Declaration( ofstream& ofile);
	virtual void PrintC( ofstream& ofile);

	virtual bool Has_No_Registered_Update();
	virtual void Assign_Expression_Value(AaValue* expr_value);
	virtual bool Is_Signal_Read();
	virtual bool Is_Indirect_Signal_Read();

	virtual bool Set_Addressed_Object_Representative(AaStorageObject* obj);

	virtual void Get_Leaf_Expression_Set(set<AaExpression*>& leaf_expression_set)
	{
		leaf_expression_set.insert(this);
	}

	virtual void Write_VC_Guard_Forward_Dependency(AaRoot* guard_expr_root, set<AaRoot*>& visited_elements, ostream& ofile);
	virtual void Write_VC_Guard_Backward_Dependency(AaExpression* expr, set<AaRoot*>& visited_elements, ostream& ofile);

	virtual void Write_VC_Output_Buffering(string dpe_name, string tgt_name, ostream& ofile);
	virtual void Write_VC_Input_Buffering(string dpe_name, string src_name, ostream& ofile);

	virtual bool Is_Implicit_Variable_Reference();
	virtual bool Is_Interface_Object_Reference();

	virtual AaRoot* Get_Root_Object();
	virtual bool Is_Implicit_Object();

	virtual void Set_Type(AaType* t);
	virtual void Evaluate();

	virtual string Get_VC_Constant_Name();
	virtual string Get_VC_Driver_Name();
	virtual string Get_VC_Receiver_Name();
	virtual void Write_VC_Control_Path( ostream& ofile);
	virtual void Write_VC_Control_Path_As_Target( ostream& ofile);
	virtual void Write_VC_Constant_Wire_Declarations(ostream& ofile);
	virtual void Write_VC_Wire_Declarations(bool skip_immediate, ostream& ofile);
	virtual void Write_VC_Wire_Declarations_As_Target(ostream& ofile);
	virtual void Write_VC_Datapath_Instances_As_Target( ostream& ofile, AaExpression* source);
	virtual void Write_VC_Datapath_Instances(AaExpression* target, ostream& ofile);
	virtual void Write_VC_Links(string hier_id, ostream& ofile);
	virtual void Write_VC_Links_As_Target(string hier_id, ostream& ofile);

	virtual string Get_VC_Name();

	virtual void Update_Type();

	virtual void Write_VC_Links_Optimized(string hier_id, ostream& ofile);
	virtual void Write_VC_Links_As_Target_Optimized(string hier_id, ostream& ofile);

	virtual void Write_VC_Control_Path_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);
	virtual void Write_VC_Control_Path_As_Target_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);


	set<AaStorageObject*>& Get_Addressed_Objects()
	{
		return(this->_addressed_objects);
	}



	virtual void Set_Associated_Statement(AaStatement* stmt)
	{
		_associated_statement = stmt;
	}

	virtual string Get_VC_Reenable_Update_Transition_Name(set<AaRoot*>& visited_elements);
	virtual string Get_VC_Unmarked_Reenable_Update_Transition_Name_Generic(set<AaRoot*>& visited_elements);
	virtual string Get_VC_Unmarked_Reenable_Update_Transition_Name(set<AaRoot*>& visited_elements);
	virtual string Get_VC_Reenable_Sample_Transition_Name(set<AaRoot*>& visited_elements);

	virtual string Get_VC_Sample_Start_Transition_Name();
	virtual string Get_VC_Sample_Completed_Transition_Name();
	virtual string Get_VC_Update_Start_Transition_Name();
	virtual string Get_VC_Update_Completed_Transition_Name();


	virtual void Update_Adjacency_Map(map<AaRoot*, vector< pair<AaRoot*, int> > >& adjacency_map, set<AaRoot*>& visited_elements);

	virtual string Get_Name();
	virtual void Replace_Uses_By(AaExpression* used_expr, AaAssignmentStatement* replacement);

	virtual bool Update_Protocol_Has_Delay(set<AaRoot*>& visited_elements);

	// added so that we can track from simple object references
	// backward through combinational statements.
	virtual void Collect_Root_Sources(set<AaRoot*>& root_set);

	virtual bool Is_Trivial();
	virtual void Write_VC_Pipelined_Module_Enable_Joins(set<AaRoot*>& visited_elements, ostream& ofile);
	void Write_VC_Joins_To_Root_Source_Updates(string trig_trans, 
							set<AaRoot*>& visited_elements, ostream& ofile);

	virtual int Get_Existing_Buffering();

	virtual bool Is_Write_To_Pipe(AaPipeObject* obj);
	virtual bool Can_Be_Combinationalized();
};



// array object reference
class AaArrayObjectReference: public AaObjectReference
{

	// indices will in general be expressions
	vector<AaExpression*> _indices;
	AaSimpleObjectReference* _pointer_ref;

	public:

	vector<AaExpression*>* Get_Index_Vector() {return(&(_indices));}

	virtual void Mark_As_Visited(set<AaRoot*>& visited_elements)
	{
		visited_elements.insert(this);
		for(int I = 0; I < _indices.size(); I++)
		{
			_indices[I]->Mark_As_Visited(visited_elements);
		}
		_pointer_ref->Mark_As_Visited(visited_elements);
	}

	virtual void Set_Pipeline_Parent(AaStatement* dws)
	{
		_pipeline_parent = dws;
		for(int i = 0, fi = _indices.size(); i < fi; i++)
			_indices[i]->Set_Pipeline_Parent(dws);
		if(_pointer_ref != NULL)
			_pointer_ref->Set_Pipeline_Parent(dws);
	}

	unsigned int Get_Number_Of_Indices() {return this->_indices.size();}

	// note: base object and all elements of index_list become children
	AaArrayObjectReference(AaScope* scope_tpr,
			string object_ref_string, 
			vector<AaExpression*>& index_list);

	AaArrayObjectReference(AaScope* scope_tpr,
			AaRoot* root_object,
			vector<AaExpression*>& index_list);

	~AaArrayObjectReference();

	AaExpression* Get_Indices(int idx)
	{
		if(idx >= 0 && idx < _indices.size())
			return(_indices[idx]);
		else
			return(NULL);
	}
	virtual void Print(ostream& ofile); 
	AaExpression* Get_Array_Index(unsigned int idx);
	virtual void Set_Object(AaRoot* obj); 


	virtual string Kind() {return("AaArrayObjectReference");}
	virtual void Map_Source_References(set<AaRoot*>& source_objects); // important
	virtual void Map_Source_References_As_Target(set<AaRoot*>& source_objects);

	virtual void PrintC_Declaration( ofstream& ofile);
	virtual void PrintC( ofstream& ofile);

        virtual string C_Reference_String(); // todo
	string C_Index_String(AaType* t, int start_id, vector<AaExpression*>* indices);
       

	void Update_Address_Scaling_Factors(vector<int>& scale_factors,int word_size);
	void Update_Address_Shift_Factors(vector<int>& shift_factors,int word_size);

	virtual void Write_VC_Control_Path( ostream& ofile);
	void Write_VC_Address_Gen_Control_Path(ostream& ofile);

	virtual void Get_Leaf_Expression_Set(set<AaExpression*>& leaf_expression_set)
	{
		for(int idx = 0; idx < _indices.size(); idx++)
			_indices[idx]->Get_Leaf_Expression_Set(leaf_expression_set);
	}

	virtual void Set_Associated_Statement(AaStatement* stmt)
	{
		_associated_statement = stmt;
		for(int idx = 0; idx < _indices.size(); idx++)
			_indices[idx]->Set_Associated_Statement(stmt);

		if(_pointer_ref != NULL)
			_pointer_ref->Set_Associated_Statement(stmt);
	}
	virtual void Set_Phi_Source_Index(int v) {
		_phi_source_index = v;
		for(int idx = 0; idx < _indices.size(); idx++)
			_indices[idx]->Set_Phi_Source_Index(v);

		if(_pointer_ref != NULL)
			_pointer_ref->Set_Phi_Source_Index(v);
	}

	virtual void Write_VC_Control_Path_As_Target( ostream& ofile);
	virtual void Evaluate();

	virtual void Write_VC_Constant_Wire_Declarations(ostream& ofile);
	virtual void Write_VC_Wire_Declarations(bool skip_immediate, ostream& ofile);
	virtual void Write_VC_Wire_Declarations_As_Target(ostream& ofile);
	virtual void Write_VC_Datapath_Instances_As_Target( ostream& ofile, AaExpression* source);
	virtual void Write_VC_Datapath_Instances(AaExpression* target, ostream& ofile);
	virtual void Write_VC_Links(string hier_id, ostream& ofile);
	virtual void Write_VC_Links_As_Target(string hier_id, ostream& ofile);
	virtual string Get_VC_Name() {return("array_obj_ref_" + Int64ToStr(this->Get_Index()));}


	virtual void Set_Type(AaType* t);
	virtual void Update_Type();


	virtual int Get_Base_Address();
	virtual string Get_VC_Base_Address_Name();
	virtual int Get_Address_Width();
	virtual int Get_Word_Size();



	virtual int Get_Access_Width();


	virtual void Write_VC_Links_Optimized(string hier_id, ostream& ofile);
	virtual void Write_VC_Links_As_Target_Optimized(string hier_id, ostream& ofile);

	virtual void Write_VC_Control_Path_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);
	virtual void Write_VC_Control_Path_As_Target_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);

	virtual bool Set_Addressed_Object_Representative(AaStorageObject* obj);

	virtual void Add_Target_Reference(AaRoot* referrer); 
	virtual void Add_Source_Reference(AaRoot* referrer);

	virtual void Update_Adjacency_Map(map<AaRoot*, vector< pair<AaRoot*, int> > >& adjacency_map, set<AaRoot*>& visited_elements);
	virtual void Replace_Uses_By(AaExpression* used_expr, AaAssignmentStatement* replacement);

	virtual string Get_VC_Base_Address_Update_Reenable_Transition(set<AaRoot*>& visited_elements);
	virtual string Get_VC_Base_Address_Update_Unmarked_Reenable_Transition(set<AaRoot*>& visited_elements);
	virtual void Collect_Root_Sources(set<AaRoot*>& root_set);
	virtual bool Can_Be_Combinationalized() {return(false);}
};


class AaPointerDereferenceExpression: public AaObjectReference
{
	AaObjectReference* _reference_to_object;
	set<AaStorageObject*> _addressed_objects_from_rhs;



	public:

	AaPointerDereferenceExpression(AaScope* scope, AaObjectReference* obj_ref);
	virtual void Mark_As_Visited(set<AaRoot*>& visited_elements)
	{
	
		visited_elements.insert(this);
		visited_elements.insert(_reference_to_object);
	}


	AaObjectReference* Get_Reference_To_Object()
	{
		return(_reference_to_object);
	}

	virtual void Set_Pipeline_Parent(AaStatement* dws)
	{
		_pipeline_parent = dws;
		_reference_to_object->Set_Pipeline_Parent(dws);
	}
	virtual void Set_Associated_Statement(AaStatement* stmt)
	{
		_associated_statement = stmt;
		_reference_to_object->Set_Associated_Statement(stmt);
	}
	virtual void Set_Phi_Source_Index(int v)
	{
		_phi_source_index = v;
		_reference_to_object->Set_Phi_Source_Index(v);
	}
	virtual void Map_Source_References_As_Target(set<AaRoot*>& source_objects)
	{
		this->_reference_to_object->Map_Source_References(source_objects);
	}

	virtual bool Is_Load() {return(!this->Get_Is_Target());}
	virtual bool Is_Store(){return(this->Get_Is_Target()); }
	virtual bool Is_Foreign_Store();
	virtual bool Is_Foreign_Load();

	virtual void Print(ostream& ofile);

	virtual void PrintC_Declaration( ofstream& ofile);
	virtual void PrintC( ofstream& ofile);

	virtual void Evaluate();
	virtual void Propagate_Addressed_Object_Representative(AaStorageObject* obj, AaRoot* from_expr);

	virtual void Map_Source_References(set<AaRoot*>& source_objects); // important
	virtual void Update_Type();
	virtual string Kind() {return("AaPointerDereferenceExpression");}

	virtual void Write_VC_Control_Path( ostream& ofile);
	virtual void Write_VC_Control_Path_As_Target( ostream& ofile);
	virtual void Write_VC_Constant_Wire_Declarations(ostream& ofile);
	virtual void Write_VC_Wire_Declarations(bool skip_immediate, ostream& ofile);
	virtual void Write_VC_Wire_Declarations_As_Target(ostream& ofile);
	virtual void Write_VC_Datapath_Instances_As_Target( ostream& ofile, AaExpression* source);
	virtual void Write_VC_Datapath_Instances(AaExpression* target, ostream& ofile);
	virtual void Write_VC_Links(string hier_id, ostream& ofile);
	virtual void Write_VC_Links_As_Target(string hier_id, ostream& ofile);

	virtual string Get_VC_Name() {return("ptr_deref_" + Int64ToStr(this->Get_Index()));}

	virtual string Get_VC_Memory_Space_Name();
	virtual int Get_VC_Memory_Space_Index();

	virtual int Get_Base_Address();
	virtual int Get_Word_Size();
	virtual int Get_Address_Width();
	virtual AaType* Get_Base_Address_Type();
	virtual string Get_VC_Base_Address_Name();

	virtual int Get_Access_Width();
	virtual void Assign_Expression_Value(AaValue* expr_value)
	{
		// cannot assign a fixed value to a stored 
		// object..
	}

	virtual void Write_VC_Links_Optimized(string hier_id, ostream& ofile);
	virtual void Write_VC_Links_As_Target_Optimized(string hier_id, ostream& ofile);

	virtual void Write_VC_Control_Path_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);
	virtual void Write_VC_Control_Path_As_Target_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);

	void Get_Siblings(set<AaPointerDereferenceExpression*>& sibling_set, bool get_sources, bool get_targets);

	virtual void Update_Adjacency_Map(map<AaRoot*, vector< pair<AaRoot*, int> > >& adjacency_map, set<AaRoot*>& visited_elements);
	virtual void Replace_Uses_By(AaExpression* used_expr, AaAssignmentStatement* replacement);

	virtual string Get_VC_Base_Address_Update_Reenable_Transition(set<AaRoot*>& visited_elements);
	virtual string Get_VC_Base_Address_Update_Unmarked_Reenable_Transition(set<AaRoot*>& visited_elements);
	virtual bool Writes_To_Memory_Space(AaMemorySpace* ms);
	virtual bool Can_Be_Combinationalized() {return(false);}
};


class AaAddressOfExpression: public AaObjectReference
{
	AaObjectReference* _reference_to_object;
	AaStorageObject* _storage_object;

	public:
	AaAddressOfExpression(AaScope* scope, AaObjectReference* obj_ref);
	virtual void Mark_As_Visited(set<AaRoot*>& visited_elements)
	{
		visited_elements.insert(this);
		visited_elements.insert(_reference_to_object);
	}

	virtual void Print(ostream& ofile);

	virtual void PrintC_Declaration( ofstream& ofile);
	virtual void PrintC(ofstream& ofile);

	virtual void Set_Associated_Statement(AaStatement* stmt)
	{
		_associated_statement = stmt;
		_reference_to_object->Set_Associated_Statement(stmt);
	}
	virtual void Set_Phi_Source_Index(int v)
	{
		_phi_source_index = v;
		_reference_to_object->Set_Phi_Source_Index(v);
	}
	virtual void Set_Pipeline_Parent(AaStatement* dws)
	{
		_pipeline_parent = dws;
		_reference_to_object->Set_Pipeline_Parent(dws);
	}
	virtual bool Is_Load() {return(false);}
	virtual bool Is_Store(){return(false);}

	virtual void Propagate_Addressed_Object_Representative(AaStorageObject* obj, AaRoot* from_expr);

	virtual void Map_Source_References(set<AaRoot*>& source_objects); // important
	virtual void Update_Type();

	virtual string Kind() {return("AaAddressOfExpression");}

	virtual void Write_VC_Control_Path( ostream& ofile);
	virtual void Write_VC_Control_Path_As_Target( ostream& ofile);
	virtual void Write_VC_Constant_Wire_Declarations(ostream& ofile);
	virtual void Write_VC_Wire_Declarations(bool skip_immediate, ostream& ofile);
	virtual void Write_VC_Wire_Declarations_As_Target(ostream& ofile);
	virtual void Write_VC_Datapath_Instances_As_Target( ostream& ofile, AaExpression* source);
	virtual void Write_VC_Datapath_Instances(AaExpression* target, ostream& ofile);
	virtual void Write_VC_Links(string hier_id, ostream& ofile);
	virtual void Write_VC_Links_As_Target(string hier_id, ostream& ofile);
	virtual string Get_VC_Name() {return("addr_of_" + Int64ToStr(this->Get_Index()));}

	virtual void Evaluate();

	virtual string Get_VC_Memory_Space_Name();
	virtual int Get_VC_Memory_Space_Index();

	virtual int Get_Base_Address();
	virtual int Get_Word_Size();
	virtual int Get_Address_Width();
	virtual AaType* Get_Base_Address_Type();
	virtual string Get_VC_Base_Address_Name();

	virtual int Get_Access_Width();

	virtual void Write_VC_Links_Optimized(string hier_id, ostream& ofile);
	virtual void Write_VC_Links_As_Target_Optimized(string hier_id, ostream& ofile);

	virtual void Write_VC_Control_Path_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);
	virtual void Write_VC_Control_Path_As_Target_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);

	virtual bool Scalar_Types_Only() { return(true);}


	virtual void Update_Adjacency_Map(map<AaRoot*, vector< pair<AaRoot*, int> > >& adjacency_map, set<AaRoot*>& visited_elements);
	virtual void Replace_Uses_By(AaExpression* used_expr, AaAssignmentStatement* replacement);

	virtual bool Can_Be_Combinationalized() {return(false);}
};


// type cast expression (is unary)
// there are three possible ways of using this
//   1. type conversion from value to value (e.g. float -> int)
//   2. bit-cast
//   3. bit-cast with slice.
//
class AaTypeCastExpression: public AaExpression
{
	protected:

	AaType* _to_type;
	AaExpression* _rest;
	bool _bit_cast;


	public:

	AaType* Get_To_Type() {return(this->_to_type);}
	AaExpression* Get_Rest() {return(this->_rest);}
	virtual void Mark_As_Visited(set<AaRoot*>& visited_elements)
	{
		visited_elements.insert(this);
		_rest->Mark_As_Visited(visited_elements);
	}

	// plain type-cast.
	AaTypeCastExpression(AaScope* scope, AaType* ref_type, AaExpression *rest);
	~AaTypeCastExpression();


	void Set_Bit_Cast(bool v) { _bit_cast = v;}
   	bool Get_Bit_Cast() { return(_bit_cast); }
	virtual void Set_Associated_Statement(AaStatement* stmt)
	{
		_associated_statement = stmt;
		_rest->Set_Associated_Statement(stmt);
	}
	virtual void Set_Phi_Source_Index(int v)
	{
		_phi_source_index = v;
		_rest->Set_Phi_Source_Index(v);
	}

	virtual void Set_Pipeline_Parent(AaStatement* dws)
	{
		_pipeline_parent = dws;
		_rest->Set_Pipeline_Parent(dws);
	}
	void Print(ostream& ofile);

	virtual void PrintC_Declaration( ofstream& ofile);
	virtual void PrintC( ofstream& ofile);

	virtual string Kind() {return("AaTypeCastExpression");}
	virtual void Map_Source_References(set<AaRoot*>& source_objects) 
	{
		if(this->_rest) 
			this->_rest->Map_Source_References(source_objects);
	}

	virtual void Write_VC_Control_Path( ostream& ofile);
	virtual void Get_Leaf_Expression_Set(set<AaExpression*>& leaf_expression_set)
	{
		_rest->Get_Leaf_Expression_Set(leaf_expression_set);
	}

	virtual void Evaluate();

	virtual void Write_VC_Constant_Wire_Declarations(ostream& ofile);
	virtual void Write_VC_Wire_Declarations(bool skip_immediate, ostream& ofile);
	virtual void Write_VC_Datapath_Instances(AaExpression* target, ostream& ofile);
	virtual void Write_VC_Links(string hier_id, ostream& ofile);
	virtual string Get_VC_Name() {return("type_cast_" + Int64ToStr(this->Get_Index()));}

	virtual void Write_VC_Links_Optimized(string hier_id, ostream& ofile);
	virtual void Write_VC_Links_As_Target_Optimized(string hier_id, ostream& ofile);

	virtual void Write_VC_Control_Path_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);
	virtual void Write_VC_Control_Path_As_Target_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);


	virtual void Update_Adjacency_Map(map<AaRoot*, vector< pair<AaRoot*, int> > >& adjacency_map, set<AaRoot*>& visited_elements);
	virtual void Replace_Uses_By(AaExpression* used_expr, AaAssignmentStatement* replacement);

	virtual string Get_VC_Reenable_Update_Transition_Name(set<AaRoot*>& visited_elements);
	virtual string Get_VC_Reenable_Sample_Transition_Name(set<AaRoot*>& visited_elements);
	virtual bool Is_Trivial();
	virtual void Collect_Root_Sources(set<AaRoot*>& root_set);
	virtual bool Can_Be_Combinationalized() 
	{
		return(this->_rest->Can_Be_Combinationalized() && 
			(this->Get_Bit_Cast() ||
				!(this->Get_To_Type()->Is_Float_Type() ||
					!this->Get_Type()->Is_Float_Type())));
	}
};

class AaSliceExpression: public AaTypeCastExpression
{
	int  _low_index;
	public:

	AaSliceExpression(AaScope* scope, AaType* to_type, int low_index, AaExpression *rest);
	virtual string Kind() {return("AaSliceExpression");}

	virtual void Evaluate();
	void Print(ostream& ofile);

	// print c declaration same as in generic expression.


	virtual void PrintC( ofstream& ofile);

	virtual bool Is_Trivial() {return(true);}
	virtual string Get_VC_Name() {return("slice_" + Int64ToStr(this->Get_Index()));}
	virtual void Write_VC_Datapath_Instances(AaExpression* target, ostream& ofile);
};

//
// unary expressions
// not B, <type-name> B, $decode B, $encode B, $bitreduce | B, $priorityencode B.
//
class AaUnaryExpression: public AaExpression
{
	protected:
	AaOperation _operation;
	AaExpression* _rest;
	public:
	AaUnaryExpression(AaScope* scope_tpr, AaOperation operation, AaExpression* rest);
	~AaUnaryExpression();
	virtual void Print(ostream& ofile); 
	virtual void Mark_As_Visited(set<AaRoot*>& visited_elements)
	{
		visited_elements.insert(this);
		_rest->Mark_As_Visited(visited_elements);
	}

	AaOperation Get_Operation() {return(this->_operation);}
	AaExpression* Get_Rest() {return(this->_rest);}
	virtual string Kind() {return("AaUnaryExpression");}
	virtual void Map_Source_References(set<AaRoot*>& source_objects) 
	{
		if(this->_rest) 
			this->_rest->Map_Source_References(source_objects);
	}

	virtual void PrintC_Declaration( ofstream& ofile);
	virtual void PrintC(ofstream& ofile);

	virtual void Set_Associated_Statement(AaStatement* stmt);
	virtual void Set_Phi_Source_Index(int v)
	{
		_phi_source_index = v;
		_rest->Set_Phi_Source_Index(v);
	}
	virtual void Set_Pipeline_Parent(AaStatement* dws)
	{
		_pipeline_parent = dws;
		_rest->Set_Pipeline_Parent(dws);
	}
	virtual void Write_VC_Control_Path( ostream& ofile);
	virtual void Get_Leaf_Expression_Set(set<AaExpression*>& leaf_expression_set)
	{
		_rest->Get_Leaf_Expression_Set(leaf_expression_set);
	}

	virtual void Update_Type();

	virtual void Evaluate();
	virtual void Write_VC_Constant_Wire_Declarations(ostream& ofile);
	virtual void Write_VC_Wire_Declarations(bool skip_immediate, ostream& ofile);
	virtual void Write_VC_Datapath_Instances(AaExpression* target, ostream& ofile);
	virtual void Write_VC_Links(string hier_id, ostream& ofile);

	virtual string Get_VC_Name();

	virtual void Write_VC_Links_Optimized(string hier_id, ostream& ofile);
	virtual void Write_VC_Links_As_Target_Optimized(string hier_id, ostream& ofile);

	virtual void Write_VC_Control_Path_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);
	virtual void Write_VC_Control_Path_As_Target_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);


	virtual void Update_Adjacency_Map(map<AaRoot*, vector< pair<AaRoot*, int> > >& adjacency_map, set<AaRoot*>& visited_elements);
	virtual void Replace_Uses_By(AaExpression* used_expr, AaAssignmentStatement* replacement);

	virtual string Get_VC_Reenable_Update_Transition_Name(set<AaRoot*>& visited_elements)
	{
		return(this->Get_VC_Update_Start_Transition_Name());
	} 

	virtual string Get_VC_Reenable_Sample_Transition_Name(set<AaRoot*>& visited_elements)
	{
		return(this->Get_VC_Sample_Start_Transition_Name());
	} 

	virtual bool Is_Trivial() {return(true);}
	virtual void Collect_Root_Sources(set<AaRoot*>& root_set);
	virtual bool Can_Be_Combinationalized() {return(this->_rest->Can_Be_Combinationalized());}
};

class AaBitmapExpression: public AaUnaryExpression
{
	vector<pair<int,int> > _bitmap_vector;
	public:

	virtual string Kind() {return("AaBitmapExpression");}
	virtual void Evaluate();
	void Check_If_Well_Formed();
	AaBitmapExpression(AaScope* scope, map<int,int>& bitmap, AaExpression *rest);
	virtual bool Is_Trivial() {return(true);}
	void Print(ostream& ofile);
	virtual void PrintC(ofstream& ofile);
	virtual string Get_VC_Name() {return("bitmap_" + Int64ToStr(this->Get_Index()));}
	virtual void Write_VC_Datapath_Instances(AaExpression* target, ostream& ofile);

};


// 
// binary expression: q + r
//
class AaBinaryExpression: public AaExpression
{
	AaOperation _operation;
	AaExpression* _first;
	AaExpression* _second;

	public:
	AaBinaryExpression(AaScope* scope_tpr, AaOperation operation, AaExpression* first, AaExpression* second);
	~AaBinaryExpression();
	virtual void Print(ostream& ofile);
	virtual void PrintC_Declaration( ofstream& ofile);
	virtual void PrintC(ofstream& ofile);
	virtual void Mark_As_Visited(set<AaRoot*>& visited_elements)
	{
		visited_elements.insert(this);
		_first->Mark_As_Visited(visited_elements);
		_second->Mark_As_Visited(visited_elements);
	}
	bool Is_Logical_Operation() 
	{ 
		if((_operation == __OR) || (_operation == __AND)
				| (_operation == __XOR) | (_operation == __NOR)
				| (_operation == __NAND) | (_operation == __XNOR))
			return(true); 
		else 
			return(false);
	} // AND/OR/XOR/XNOR/NAND/NOR are flagged.

	AaOperation Get_Operation() {return(this->_operation);}
	AaExpression* Get_First() {return(this->_first);}
	AaExpression* Get_Second() {return(this->_second);}
	virtual string Kind() {return("AaBinaryExpression");}
	virtual void Map_Source_References(set<AaRoot*>& source_objects) 
	{
		if(this->_first) this->_first->Map_Source_References(source_objects);
		if(this->_second) this->_second->Map_Source_References(source_objects);
	}
	virtual void Set_Associated_Statement(AaStatement* stmt)
	{
		_associated_statement = stmt;
		_first->Set_Associated_Statement(stmt);
		_second->Set_Associated_Statement(stmt);
	}
	virtual void Set_Phi_Source_Index(int v)
	{
		_phi_source_index = v;
		_first->Set_Phi_Source_Index(v);
		_second->Set_Phi_Source_Index(v);
	}
	virtual void Set_Pipeline_Parent(AaStatement* dws)
	{
		_pipeline_parent = dws;
		_first->Set_Pipeline_Parent(dws);
		_second->Set_Pipeline_Parent(dws);
	}

	virtual void Update_Type();


	virtual void Write_VC_Control_Path( ostream& ofile);

	virtual void Get_Leaf_Expression_Set(set<AaExpression*>& leaf_expression_set)
	{
		_first->Get_Leaf_Expression_Set(leaf_expression_set);
		_second->Get_Leaf_Expression_Set(leaf_expression_set);
	}


	virtual bool Is_Trivial();
	virtual bool Can_Be_Combinationalized() {return(this->_first->Can_Be_Combinationalized() && this->_second->Can_Be_Combinationalized() &&
											this->Is_Trivial());}
	virtual void Evaluate();
	virtual void Write_VC_Constant_Wire_Declarations(ostream& ofile);
	virtual void Write_VC_Wire_Declarations(bool skip_immediate, ostream& ofile);
	virtual void Write_VC_Datapath_Instances(AaExpression* target, ostream& ofile);
	virtual void Write_VC_Links(string hier_id, ostream& ofile);

	string Get_VC_Name();

	virtual void Write_VC_Links_Optimized(string hier_id, ostream& ofile);
	virtual void Write_VC_Links_As_Target_Optimized(string hier_id, ostream& ofile);

	virtual void Write_VC_Control_Path_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);
	virtual void Write_VC_Control_Path_As_Target_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);


	virtual void Update_Adjacency_Map(map<AaRoot*, vector< pair<AaRoot*, int> > >& adjacency_map, set<AaRoot*>& visited_elements);
	virtual void Replace_Uses_By(AaExpression* used_expr, AaAssignmentStatement* replacement);

	virtual string Get_VC_Reenable_Update_Transition_Name(set<AaRoot*>& visited_elements)
	{
		return(this->Get_VC_Update_Start_Transition_Name());
	} 

	virtual string Get_VC_Reenable_Sample_Transition_Name(set<AaRoot*>& visited_elements)
	{
		return(this->Get_VC_Sample_Start_Transition_Name());
	} 

	virtual void Write_VC_Guard_Forward_Dependency(AaRoot* guard_expr_root, set<AaRoot*>& visited_elements, ostream& ofile);
	virtual void Write_VC_Guard_Backward_Dependency(AaExpression* expr, set<AaRoot*>& visited_elements, ostream& ofile);


	void Write_VC_Links_BLE_Optimized(string hier_id, ostream& ofile);
	void Write_VC_Control_Path_BLE_Optimized(bool pipeline_flag, set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);

	virtual void Collect_Root_Sources(set<AaRoot*>& root_set);
};

// ternary expression: a ? b : c
class AaTernaryExpression: public AaExpression
{
	AaExpression* _test;
	AaExpression* _if_true;
	AaExpression* _if_false;
	public:
	AaTernaryExpression(AaScope* scope_tpr, AaExpression* test,AaExpression* iftrue, AaExpression* iffalse);
	~AaTernaryExpression();

	virtual void Print(ostream& ofile); 

	AaExpression*      Get_Test() {return(this->_test);}
	AaExpression* Get_If_True() {return(this->_if_true);}
	AaExpression* Get_If_False() {return(this->_if_false);}
	virtual string Kind() {return("AaTernaryExpression");}
	virtual void Map_Source_References(set<AaRoot*>& source_objects) 
	{
		if(this->_test) this->_test->Map_Source_References(source_objects);
		if(this->_if_true) this->_if_true->Map_Source_References(source_objects);
		if(this->_if_false) this->_if_false->Map_Source_References(source_objects);
	}
	virtual void Mark_As_Visited(set<AaRoot*>& visited_elements)
	{
		visited_elements.insert(this);
		_test->Mark_As_Visited(visited_elements);
		_if_true->Mark_As_Visited(visited_elements);
		_if_false->Mark_As_Visited(visited_elements);
	}

	virtual void Set_Associated_Statement(AaStatement* stmt)
	{
		_associated_statement = stmt;
		_test->Set_Associated_Statement(stmt);
		_if_true->Set_Associated_Statement(stmt);
		_if_false->Set_Associated_Statement(stmt);
	}
	virtual void Set_Phi_Source_Index(int v)
	{
		_phi_source_index = v;
		_test->Set_Phi_Source_Index(v);
		_if_true->Set_Phi_Source_Index(v);
		_if_false->Set_Phi_Source_Index(v);
	}
	virtual void Set_Pipeline_Parent(AaStatement* dws)
	{
		_pipeline_parent = dws;
		_test->Set_Pipeline_Parent(dws);
		_if_true->Set_Pipeline_Parent(dws);
		_if_false->Set_Pipeline_Parent(dws);
	}

	virtual void PrintC_Declaration( ofstream& ofile);
	virtual void PrintC( ofstream& ofile);

	virtual void Write_VC_Control_Path( ostream& ofile);
	virtual void Write_VC_Constant_Wire_Declarations(ostream& ofile);
	virtual void Write_VC_Wire_Declarations(bool skip_immediate, ostream& ofile);
	virtual void Write_VC_Datapath_Instances(AaExpression* target, ostream& ofile);
	virtual void Write_VC_Links(string hier_id, ostream& ofile);

	virtual void Get_Leaf_Expression_Set(set<AaExpression*>& leaf_expression_set)
	{
		_test->Get_Leaf_Expression_Set(leaf_expression_set);
		_if_true->Get_Leaf_Expression_Set(leaf_expression_set);
		_if_false->Get_Leaf_Expression_Set(leaf_expression_set);
	}

	virtual void Evaluate();

	string Get_VC_Name();

	virtual void Write_VC_Links_Optimized(string hier_id, ostream& ofile);
	virtual void Write_VC_Links_As_Target_Optimized(string hier_id, ostream& ofile);

	virtual void Write_VC_Control_Path_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);
	virtual void Write_VC_Control_Path_As_Target_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);



	virtual void Update_Adjacency_Map(map<AaRoot*, vector< pair<AaRoot*, int> > >& adjacency_map, set<AaRoot*>& visited_elements);
	virtual void Replace_Uses_By(AaExpression* used_expr, AaAssignmentStatement* replacement);


	virtual string Get_VC_Reenable_Update_Transition_Name(set<AaRoot*>& visited_elements)
	{
		return(this->Get_VC_Update_Start_Transition_Name());
	}
	virtual string Get_VC_Reenable_Sample_Transition_Name(set<AaRoot*>& visited_elements)
	{
		return(this->Get_VC_Sample_Start_Transition_Name());
	}
	virtual void Collect_Root_Sources(set<AaRoot*>& root_set);
	virtual bool Is_Trivial() {return(this->Get_Is_Intermediate());}
	virtual bool Can_Be_Combinationalized() {return(this->_test->Can_Be_Combinationalized() 
								&& this->_if_true->Can_Be_Combinationalized()
								&& this->_if_false->Can_Be_Combinationalized());}
	//virtual bool Is_Trivial() {return(false);}
};

class AaFunctionCallExpression: public AaExpression
{
	string _module_identifier;
	AaModule* _called_module;

	vector<AaExpression*> _arguments;
	public:

	AaFunctionCallExpression(AaScope* scope, string module_id,
					vector<AaExpression*>& arguments);
	~AaFunctionCallExpression();	

	virtual void Print(ostream& ofile); 

	AaModule* Get_Called_Module() {return (_called_module);}
	virtual bool Is_Opaque_Function_Call_Expression();

	AaExpression*      Get_Argument(int id) 
	{
		if((id >= 0) && (id < _arguments.size()))
			return(_arguments[id]);
		else
			return(NULL);
	}
	virtual string Kind() {return("AaFunctionCallExpression");}
	virtual void Map_Source_References(set<AaRoot*>& source_objects);
	virtual void Mark_As_Visited(set<AaRoot*>& visited_elements)
	{
		visited_elements.insert(this);
		for(int I = 0, fI = _arguments.size(); I < fI; I++)
		{
			this->_arguments[I]->Mark_As_Visited(visited_elements);
		}
	}

	virtual void Set_Associated_Statement(AaStatement* stmt)
	{
		_associated_statement = stmt;
		for(int I = 0, fI = _arguments.size(); I < fI; I++)
		{
			this->_arguments[I]->Set_Associated_Statement(stmt);
		}
	}
	virtual void Set_Phi_Source_Index(int v)
	{
		_phi_source_index = v;
		for(int I = 0, fI = _arguments.size(); I < fI; I++)
		{
			this->_arguments[I]->Set_Phi_Source_Index(v);
		}
	}
	virtual void Set_Pipeline_Parent(AaStatement* dws)
	{
		_pipeline_parent = dws;
		for(int I = 0, fI = _arguments.size(); I < fI; I++)
		{
			this->_arguments[I]->Set_Pipeline_Parent(dws);
		}
	}


	virtual void Get_Leaf_Expression_Set(set<AaExpression*>& leaf_expression_set)
	{
		for(int I = 0, fI = _arguments.size(); I < fI; I++)
		{
			this->_arguments[I]->Get_Leaf_Expression_Set(leaf_expression_set);
		}
	}

	virtual string Get_VC_Reenable_Update_Transition_Name(set<AaRoot*>& visited_elements)
	{
		return(this->Get_VC_Update_Start_Transition_Name());
	}
	virtual string Get_VC_Reenable_Sample_Transition_Name(set<AaRoot*>& visited_elements)
	{
		return(this->Get_VC_Sample_Start_Transition_Name());
	}

	virtual void PrintC_Declaration( ofstream& ofile);
	virtual void PrintC( ofstream& ofile);
	virtual void Write_VC_Control_Path( ostream& ofile);
	virtual void Write_VC_Constant_Wire_Declarations(ostream& ofile);
	virtual void Write_VC_Wire_Declarations(bool skip_immediate, ostream& ofile);
	virtual void Write_VC_Datapath_Instances(AaExpression* target, ostream& ofile);
	virtual void Write_VC_Links(string hier_id, ostream& ofile);
	virtual void Evaluate();
	string Get_VC_Name();

	virtual void Write_VC_Links_Optimized(string hier_id, ostream& ofile);
	virtual void Write_VC_Links_As_Target_Optimized(string hier_id, ostream& ofile);

	virtual void Write_VC_Control_Path_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);
	virtual void Write_VC_Control_Path_As_Target_Optimized(bool pipeline_flag,
			set<AaRoot*>& visited_elements,
			map<AaMemorySpace*,vector<AaRoot*> >& ls_map,
			map<AaPipeObject*,vector<AaRoot*> >& pipe_map,
			AaRoot* barrier,
			ostream& ofile);



	virtual void Update_Adjacency_Map(map<AaRoot*, vector< pair<AaRoot*, int> > >& adjacency_map, set<AaRoot*>& visited_elements);
	virtual void Replace_Uses_By(AaExpression* used_expr, AaAssignmentStatement* replacement);


	virtual void Collect_Root_Sources(set<AaRoot*>& root_set);
	virtual bool Is_Trivial(); // return false if called module is volatile.
	virtual bool Is_Volatile_Function_Call() {return(this->Is_Trivial());}
	virtual bool Can_Be_Combinationalized();

  	virtual bool Is_Write_To_Pipe(AaPipeObject* obj);
  	virtual bool Writes_To_Memory_Space(AaMemorySpace* ms);
	virtual bool Get_Is_Volatile();
};




AaExpression* Make_Reduce_Expression(AaScope* scope, int line_no, AaOperation op,  vector<AaExpression*>& expr_vector);
AaExpression* Make_Priority_Mux_Expression(AaScope* scope, int line_no, int sindex, 
						vector<pair<AaExpression*,AaExpression*> >& expr_vector,
						AaExpression* default_expr);
AaExpression* Make_Exclusive_Mux_Expression(AaScope* scope, int line_no, int sindex,  int findex,
				vector<pair<AaExpression*,AaExpression*> >& expr_vector);


#endif
