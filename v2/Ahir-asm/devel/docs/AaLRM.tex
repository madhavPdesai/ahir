\documentclass{article}

\title{Aa Language Reference Manual}
\author{Madhav Desai \\ Department of Electrical Engineering \\ Indian Institute of Technology \\
	Mumbai 400076 India}

\newcommand{\Aa}{{\bf Aa}~}
\newcommand{\vC}{{\bf vC}~}

\begin{document}
\maketitle

\section{Introduction}

{\bf Aa} is a programming language for the 
description of algorithms, with the ultimate aim
being the conversion of these algorithms into 
a hardware implementation.   The control-flow
in an \Aa program corresponds to a petri net
of a specific class.
The data-flow is constructed using static
single-assignment variables (which can be assigned to only once),
storage objects, messaging pipes and constants.
Pointers to storage objects can be created
and manipulated (pointer arithmetic, dereferencing
etc.) in the usual way.  

A program in \Aa can also be viewed as a 
description of a system which reacts with 
its environment through input and output ports.
Thus, an \Aa program can either be executed on a 
computer, or be mapped to a logic circuit.

In the rest of this document, we outline the
structure and the syntax of the \Aa language,
and also describe the semantics of an \Aa
program, especially the execution model and
the behaviour of the equivalent system.


\section{Program structure}


A program in \Aa consists of a sequence of
declarations and module definitions.  
\begin{verbatim}
program := ( module-definition | program-variable-declaration )*
\end{verbatim}
Program variable declarations
can belong to one of three classes as described in Section \ref{sec:Objects}.

A module in \Aa is the basic unit of compilation, and
has the following structure
\begin{verbatim}
$module [module-name] 
   $in(<input-arguments>)
   $out(<output-arguments>)
$is
{
   <object-declarations>
   <sequence-of-statements>
}
\end{verbatim}
Thus, a module has a name, has input and output arguments,
declares objects and consists of a sequence of statements.
Objects (storage/pipe/constant) declared in the module are visible only in the
module body.   For example:
\begin{verbatim}
$module [sum] 
   $in (a: $uint<32> b: $uint<32>) 
   $out (c : $uint<32>)
$is
{
   c := (a+b)
}
\end{verbatim}
In this example, {\em sum} is 
a module which has two inputs and a single output.
The type of the inputs and the output is 
\begin{verbatim}
$uint<32>
\end{verbatim}
which is an unsigned 32-bit integer (More details
on types are given in Section \ref{sec:Types}).

Each statement in the sequence
of statements can be abstractly 
viewed as a region
in a petri-net,  and has a 
set of input (or source) places  and a set of output
(or sink)  places.  
The execution of the statement is triggered when
there is a token present in every place in some specified subsets
of its source 
places and when the statement finishes execution,
a token is placed in some specified subset of its sink places.   

The control flow in the sequence of statements
in a module is serial in nature.  Thus each
statement has a single source place and a single
sink place, with the sink place of a statement being 
the source place of its successor.
The module as a whole can be viewed as having
a single entry place and a single exit place.
When a token appears in the entry place, the first
statement can trigger, and when the last statement
has finished, a token is placed in the exit
place.  

The region between \{ and \} is termed a {\bf scope}.  Thus, 
a module description defines a scope.  In this case, 
the scope has a label which is the same as the module name.
As we shall see later, the statements in the statement sequence
may in turn define scopes.  Each scope defines a name-space.  
The visibility
rules and access mechanisms between scopes will be described
in Section \ref{sec:Scopes}.

\section{Program Variables} \label{sec:Objects}

Variables in  the program can belong to the following classes:
\begin{itemize}
\item {\bf Parameters} can be used to configure the Aa program to
a certain extent.  These are 32-bit integers declared as
\begin{verbatim}
$parameter PIPEDEPTH 16
$parameter PIPEDEPTH2  {2 * PIPEDEPTH} 
\end{verbatim}
for example.    Note that the parameter
PIPEDEPTH2 is obtained by evaluating the
parameter expression 
\begin{verbatim}
{2 * PIPEDEPTH} 
\end{verbatim}
Parameter expressions  are described in more detail Section \ref{sec:ParamExprs}.
Parameters can be used to specify some 
constants inside
the program (this will be indicated whenever relevant).
Parameters
should be known at the point at which they are used.  Also,
parameters can be declared only at global program scope (that is
not inside a module).
\item {\bf Storage} variables declared in the program
can be written into from multiple
points in the program.  When declared at the program
scope, storage variables are visible throughout
the program.  Storage variables can be thought of 
as memory locations which can be accessed from different
points in the program.
A storage variable declaration has the form
\begin{verbatim}
$storage <var-name>: <var-type> 
\end{verbatim}
For example
\begin{verbatim}
$storage mempool: $array [1024] $of $uint<32>
\end{verbatim}
\item {\bf Pipe} variables declared at the program scope
are globally visible buffers (which
can be defined to be either first-in-first-out (FIFO) or
last-in-first-out (LIFO)) that can 
be read from anywhere in the program and can be
written into from anywhere in th program.  A pipe
is a FIFO (or FIFO) buffer with a specified number of
slots.  A write to a pipe succeeds
only if there is an empty slot in the FIFO (a successful
write uses up an empty slots.  A read
from the pipe succeeds only if there is at
least one occupied slot in the pipe (a successful read
creates an empty slot in the pipe). 
Thus, pipes can be used to model queues as
well as stacks, and also provide a mechanism for synchronization and
for message passing in an \Aa program.
\begin{itemize}
\item A pipe that is only written into in the program, but
is not read from, is assumed to have a destination outside
the program.  Such a pipe is an output port of the
program.
\item A pipe that is only read from in a program but not
written into, is assumed to have a source outside the program.
Such a pipe is an input port of the program.
\end{itemize}
A pipe declaration has the form
\begin{verbatim}
($lifo | $noblock)? $pipe <pipe-name>: <pipe-type>  ($depth <integer>)?
\end{verbatim}
For example
\begin{verbatim}
$pipe myfifo: $uint<32> $depth 16 // 16-slot queue
$lifo $pipe mystack: $uint<32> $depth 4 // 4-slot stack
$noblock $pipe cmd_pipe: $uint<8> // non-blocking reads.
\end{verbatim}
A non-blocking pipe when read, will deliver $0$ if
it does not contain data (thus, you will have to reserve
the $0$ for invalid data).

Pipe variable declarations can also be appended by
the following keywords:
\begin{verbatim}
   ($in | $out)? ($signal)? 
\end{verbatim}
These additional keywords mean the following things:
\begin{itemize}
\item Inclusion of ``\$in'' (respectively ``\$out'') means
that the pipe is a read-only (respectively write-only) object.
\item The ``\$signal'' keyword means that the pipe behaves
like a variable.  That is, it remembers the last value
that was written to it\footnote{Note that the signal is initialized to 0.}.
\end{itemize}
Pipe depths can be specified by parameters or parameter
expressions.
\item {\bf Constant} variables declared at
the program scope are globally visible and have
initial values which can never be altered in the program.
Thus, an assignment to a constant is an error.
A constant declaration has the form
\begin{verbatim}
$constant <constant-name>: <constant-type> := <initial-value>
\end{verbatim}
For example
\begin{verbatim}
$constant wordlength: $uint<32> := 16
\end{verbatim}
\item {\bf Implicit} or {\bf Static Single Assignment}
variables are created by statements in the \Aa program
(as described below in Section \ref{sec:Statements}).
These are analogous to registers that can be written
into only from one point,  but can be
read from several points in the program.
Implicit variables are not declared, but are defined
by the statements which write to them.
\end{itemize} 


\section{Statements} \label{sec:Statements}
 
Statements in the module-body are can be of two kinds:
\begin{itemize}
\item Complete or atomic statements: these are statements
which have a single
entry place and a single exit place.  These are
the only statements that can occur in a module body.
These statements are further divided into 
{\em simple} statements and {\em block} statements.
\item Incomplete or sub-atomic statements:  these statements
can appear only inside block statements,  and they
can have multiple source and sink places.
Examples of these statements are statements for
combining tokens (merge and join statements) and
statements for redirecting tokens (the place statement).
\end{itemize}


\subsection{Complete Statements}

Complete statements can be one of the following:
\begin{itemize}
\item An {\bf assignment} statement is of the form
\begin{verbatim}
target-ref := expression
\end{verbatim}
where {\em target-ref} either specifies a declared object
or an undeclared name.  If it is an undeclared name, then
it is an implicit variable that is attached to the
assignment statement.  No other statement can write to this
variable, but any statement can read from this variable
subject to scoping rules.  Thus, every implicit variable
is such that exactly one statement defines its value.
When control flow reaches an assignment statement, it
evaluates the expression, updates the value of the target
and passes the control flow forward (we will see what this
means in the sequel).
Some examples of assignment statements are 
\begin{verbatim}
a  :=  (~b)
b  :=   (c + (d + e))
\end{verbatim}
etc.   Expressions can be {\em unary},
{\em binary} or {\em ternary}, and are
described in detail in Section \ref{sec:Expressions}.
Details of the syntax are provided in 
Section \ref{sec:Syntax}.

An assignment statement can be marked as a volatile
\begin{verbatim}
$volatile a := (b+c)
\end{verbatim}
which means that $a$ will be generated from $b,c$, but
the logic which updates $a$ can be combinational.

\item A {\bf call} statement is of the form
\begin{verbatim}
call-spec module-name input-arguments output-arguments
\end{verbatim}
The call statement thus specifies a module to which control flow
is to be passed.  The call statement may itself define new implicit
variables through its specified targets (and thus is the only
statement that can modify these newly defined implicit variables).
When control flow reaches the call statement, it forwards the
token to the called module, and finishes when the token exits
the called module.  Recursive calls and cyclical dependencies between
modules through call statements are not permitted in the \Aa language.
Here is an example of a call statement
\begin{verbatim}
// pass control to a module named foo
// foo has two inputs and three outputs
$call foo (p q)  (r s t)
\end{verbatim}
Here $p,q,r,s,t$ can be expressions.

A call statement must be marked as a volatile
if the corresponding called module is volatile
\begin{verbatim}
$volatile $call foo (b c) (a)
\end{verbatim}
which means that $a$ will be generated from $b,c$, but
the logic which updates $a$ can be combinational.

\item The {\bf null} statement does nothing, and just passes the
token onwards.  This is how it looks like
\begin{verbatim}
$null
\end{verbatim}
\end{itemize}

Complete atomic statements can have a guard predicate
specified, so that they are executed only if the guard
predicate is true.  This is specified either by
\begin{verbatim}
$guard ( <guard-variable> )  <statement-spec>
\end{verbatim}
or 
\begin{verbatim}
$guard ( ~ <guard-variable> )  <statement-spec>
\end{verbatim}
For example
\begin{verbatim}
$guard (sel_add) r := (a + b)
\end{verbatim}
or
\begin{verbatim}
$guard (~ sel_add) $call afun (a b) (r)
\end{verbatim}

Complete atomic statements can be explicitly sequenced using
the \$mark and \$synch constructs.  For example
\begin{verbatim}
a := (b + c) $mark FIRST
e := (f + g) $mark SECOND $synch (FIRST)
h := (i + j) $synch ($update FIRST SECOND)
\end{verbatim}
means that the second statement will be {\em started}
only after the first statement has {\em started}.  The
third statement will be started only after the first
has finished and the second has started. This
is necessary in some cases where dependency analysis
says that two statements are independent, but you wish
to force explicit ordering.

A related construct is \$delay which explicitly sets
the delay between the completion of two statements
(which otherwise seem unrelated)
\begin{verbatim}
// from_pipe, to_pipe are pipes.
to_pipe := (a + b) $mark WPIPE
e := from_pipe  $delay (WPIPE 10)
\end{verbatim}
This says that there is delay of 10 units (clock cycles)
between the write to to\_pipe and the read from from\_pipe.
This delay information is used by the compiler to 
balance pipelines.

The {\bf Aa} compiler will optimize away dangling
assignment statements (whose targets are not
used any where in the program). In order to prevent
this from happening, you can use the \$keep keyword.
\begin{verbatim}
sacrifical_value := signal_from_somwhere $keep
\end{verbatim}
The \$keep keyword must be placed after the \$delay
keyword.

More details of the syntax are provided in 
Section \ref{sec:Syntax}.

\subsection{Reporting and trace statements}

It is possible to convert an {\bf Aa} description
to C and then execute this C description.  During
the execution, we can generate log messages using the
following statement:
\begin{verbatim}
$rreport (Descriptor  Comment  var1 var2 .. varn)
\end{verbatim}
This generates a message during execution with
the following format.
\begin{verbatim}
Descriptor    Comment
         var1 <var1-value>
         var2 <var1-value>
         ....
         varn <varn-value>
\end{verbatim}

Another useful statement is the assert statement.
\begin{verbatim}
$assert (expr)
   $rreport (Descriptor  Comment  var1 var2 .. varn)
\end{verbatim}
This prints a report if expr is false, and then
exits the execution.

Finally, we have
\begin{verbatim}
$trace simple-identifier [ ( integer-level) ]
\end{verbatim}
This produces a message
\begin{verbatim}
TRACE simple-identifier
\end{verbatim}
it the trace-level (set in the execution of the AA2C
model) is set to integer-level or lower.

Note that these statements are not converted to hardware.


\subsection{A synthetic statement: the \$split statement}

Often, we need to split a large vector into several pieces.
Suppose you want
to split a 32 bit variable into two 8-bit variables
and four 4-bit variables.  This can be done using
\begin{verbatim}
$split (X 8 8 4 4 4 4) (a8 b8 c4 d4 e4 f4)
\end{verbatim}
This is actually translated to the following
sequence of assignment statements.
\begin{verbatim}
a8 := ($slice X 31 24)
a7 := ($slice X 23 16)
c4 := ($slice X 15 12)
...
f4 := ($slice X 3 0)
\end{verbatim}

\subsection{Complete Block Statements}

Block statements can be used to describe complex
control flow,  and consist of a sequence of statements.
Block statements are of
the following types:
\begin{itemize}
\item {\bf Series} block statements are of the form
\begin{verbatim}
series-block-statement :=
             series-block-specifier block-name
             { 
                declarations
                sequence-of-atomic-statements
             } [(variable-exports)]
\end{verbatim}
The behaviour is similar to the module, in that the control
token flows serially down the sequence of statements.
Here is an example:
\begin{verbatim}
$seriesblock [s1] 
{
   $storage b $uint<32>
   b := a
   b := ( $mux (a > c)  (b+c) (b-c))
   q := ( b * 2)
} ( q => q )
\end{verbatim}
In this example, the variable $b$ was declared as
a storage variable in scope s1, and hence was legally
able to be the target of multiple assignment statements.
The optional export specification
\begin{verbatim}
( q => q )
\end{verbatim}
after the curly brace \} specifies that the variable
$q$ defined inside the block $s1$ is visible outside
the block as $q$ (so that other scopes can use this
variable, see Section \ref{sec:Scopes} below).
\item {\bf Parallel} block statements are of the form
\begin{verbatim}
parallel-block-statement :=
             parallel-block-specifier block-name
             { 
                declarations
                sequence-of-atomic-statements
             } [(variable-exports)]
\end{verbatim}
When a token enters the parallel block statement, it
is replicated into as many tokens as there are statements in
the sequence, and all statements are started in parallel.
When all statements have finished and released their token,
the parallel block statement
ends and a single token exits the parallel block statement (this
is essentially a fork followed by a join).
Here is an example
\begin{verbatim}
$parallelblock [p1] 
{
   b := a + c
   d := a - c
}
\end{verbatim} %$
The two statements will start in parallel, and the block 
will finish when both have finished.  The
order in which the two statements are executed
is {\bf not} specified.
\item {\bf Fork} block statements are generalizations of the
parallel block region, and they allow the programmer to express 
complex fork-join interactions.
They have the following structure:
\begin{verbatim}
fork-block-statement :=
             fork-block-specifier block-name
             {
                declarations
                sequence-of-statements
             } [(variable-exports)]
\end{verbatim}
The control flow is similar to the parallel block region,
in the sense that all statements in the sequence are started
in parallel, and the fork block statement ends when all statements
in the sequence have ended.  The difference is that
fork blocks can have an additional statement which
allows the programmer to provide additional synchronization
points.  These statements are termed {\bf join} statements
and have the form
\begin{verbatim}
join-statement :=
         join-specifier list-of-labels 
          fork-specifier  list-of-statements
\end{verbatim}
The meaning of this statement is that it waits until all statements
in the list-of-labels have finished, then starts the list-of-statements
(in parallel) and finishes.  This essentially defines a node in a directed graph,
with the arcs corresponding to statements in the statement-lists.  
The join indicates the arcs (or statements) 
from whom tokens have to arrive.  After all tokens have arrived
on the incoming arcs, tokens are sent along the outgoing arcs specified
in the list of statements following the optional fork specifier.  There is an implicit fork
at the entry point to the fork block statement and an implicit join at the
end of the fork block statement.  It is thus easy to describe
an arbitrary directed graph with arbitrary forks and joins.  The only
restriction is that this directed graph must be acyclic!  This is enforced
by requiring that a join statement refers only to labels of statements
that appear before the join.
Here is an example:
\begin{verbatim}
$forkblock [f1] {
  a := (b+c)
  $seriesblock [s1] { ... }
  $seriesblock [s2] { ... }
  $seriesblock [s3] { ... }
  $join s1 s2 $fork 
      $seriesblock [s4] { ... }
  $join s3 s4
}
\end{verbatim}
In this example, the first assignment statement as well as s1, s2, s3 are 
started in parallel. When both s1 and s2 have finished, s4 is started and
when s3, s4 have joined and when the first assignment statement has
finished, the forkblock f1 finishes execution.
\item {\bf Branch} block statements are constructs which allow the programmer
to describe arbitrary sequential branching behaviour.  They 
describe a control flow in which a single token 
is active within the block.  The movement of this token is
controlled by special flow control statements.
A branch block is constructed 
as follows
\begin{verbatim}
branch-block-statement :=
             branch-block-specifier block-name
             { 
		 branch-block-statement-sequence 
	     } [(variable-exports)]
\end{verbatim}
The sequence of statements appearing in a branch block
consist of
\begin{itemize}
\item Simple statements or Block statements.
\item Switch statements: A switch statement has
the form
\begin{verbatim}
switch-statement :=
         switch-spec switch-expression
           ( expr-value  branch-block-statement-sequence )*
           ( default branch-block-statement-sequence )?
         end-switch-spec
\end{verbatim}
The switch-expression is checked, and depending on its
value, one of the alternative statements is selected.
Thus, the incoming token to the switch statement is 
passed to one of the alternatives.  For example,
\begin{verbatim}
$switch a $when 0 $then a1 := (b + c)
          $when 1 $then a2 := (b - c)
          $default $null
$endswitch
\end{verbatim}
The control token is routed to the appropriate
choice sequence and if the token is not routed out 
of the block (by the {\bf place} statement 
described below), then the token passes to the
statement following the switch. 
\item If statements: An if statement has the form
\begin{verbatim}
if-statement :=
       if-spec test-expression 
           branch-block-statement-sequence
       (else
           branch-block-statement-sequence)?
       end-if-spec
       
\end{verbatim}
For example:
\begin{verbatim}
$if (a != 0) $then
   q := (r + s)
   t := 0
$else
   qdash :=  (r - s)
$endif
\end{verbatim}
If the control token reaches the end of a selected
segment in the if statement (that is, without being
rerouted by a place statement), then the control
token is passed on to the statement immediately
following the if statement.
\item The place statement: The {\bf place} statement
identifies a place which will contain 
a token after the place statemet has executed.  For example,
\begin{verbatim}
$place [fastpath]
\end{verbatim}%$
means that the incoming token is placed in a labeled
place {\bf fastpath} (the place statement never
puts a token into its default exit place).  
The token placed in {\bf fastpath} must be used to
trigger a unique {\bf merge} statement which is required
to depend on this labeled place in the same branch
block. If no such merge exists, or if multiple such merges exist, 
then this is an error.
\item Merge statements: A merge statement is
specified as 
\begin{verbatim}
merge-statement :=
          merge-spec label-list merge-assignments end-merge-spec
\end{verbatim}
which is to be interpreted as follows.  The labels in the label list
refer to token labels defined by {\bf place}  statements within the branch block.
Whenever a token is present in any of the places in
the label-list for a merge,
the merge statement starts and executes a series of special assignments
which multiplex values into targets based on which arc the
token arrived from.  The merge statement then releases its token to
the next statement. 
\begin{itemize}
\item 
The merge assignments inside a merge block are all of a specific
form, called the phi-statement.  A phi-statement has the following
form
\begin{verbatim}
phi-spec target-expr := expr1 on-spec place-spec-1  
                         [expr2 on-spec place-spec-2 ... ]
\end{verbatim}
For example:
\begin{verbatim}
$phi a := b $on $entry c $on loopback 
\end{verbatim}
This says that the target $a$ is to take the value of $b$ if
the merge statement was started from its entry place (from a
token passed from its predecessor) and is to take the value of $c$
if the merge statement was started from the place ``loopback''.
Note that if the merge statement is to be triggered by a
token in its default entry place, one of the labels in the
label-list for the merge must contain the identifier \$entry,
which corresponds to the merge statement being triggered
by the immediately preceding statement.
The target of a phi-statement must be an implicit variable
(declared by the statement itself, not a storage or a pipe
object).
\end{itemize}
\end{itemize}

Here is an example of a branch block constructed in this manner
\begin{verbatim}
$branchblock [b1] 
{
  $merge loopback $entry // $entry is the entry place
                         // of the merge statement.
                         // this merge is triggered by
                         // a token entering it from
                         // its predecessor or by  
                         // a token in the place "loopback"


       $phi q := 0 on $entry r on loop 
                    // q is defined by where 
                    // the token came from
  $endmerge
  r := (q + 1)
  $if (r < 10) $then 
       $place [loopback] // put token in place "loopback"
  $endif
} (r => r)
\end{verbatim}%$
This is to be interpreted as follows: the merge executes
whenever a token is present in its entry place  or in 
the place labeled {\bf loopback}
The merge defines variable {\bf q} with a value which is
either 0 (if a token was present in the entry place)
or r (if a token was present in the ``loop'' place).
By the construction rules in an \Aa program, it is
impossible for there to be a token present in more
than one input place to a merge.  The final export
makes $r$ directly visible as $r$  in the parent scope of the
branch-block.
\end{itemize}

\subsubsection{Careful! The phi-statements in a merge block are concurrent}

Note that the phi-statements in a merge are concurrent, and
may execute in any order.
An example:
\begin{verbatim}
  $merge loopback $entry // $entry is the entry place
     $phi p := 0 $on $entry np $on loopback
     $phi q := 0 $on $entry p  $on loopback
  $endmerge
\end{verbatim}
In this case, the two $phi$ statements may execute
in any order, and thus the value on $q$ after the execution
is indeterminate.  To prevent such race conditions, do not
use the result of a $phi$ as an input to another $phi$ in
the same merge block.


\subsection{Pipelinable-loops: the {\bf dopipeline-while} construct}

The \Aa language provides a single construct for describing loops.
The form of the construct is
\begin{verbatim}
  $dopipeline
     $merge $entry $loopback
       <phi-statements>
     $endmerge
     atomic-statement-sequence
  $while <condition-expression>
\end{verbatim}
The do-while statement can appear only in branch-blocks.  Control enters
the do-while from a predecessor in the branch-block, and stays in the
do-while as long as the condition-expression is false (the test is done
every time the loop body has finished).  The \$loopback
place is used to repeat the loop-body.  The leading merge statement
in the do-while is used to merge the control-flow coming in either from
the entry to the do-while or from the loopback place.

The downstream tools will always attempt to pipeline the do-while loop by
starting the next iteration while the current one is still in progress.
Dependency analysis on values in the loop-body is used to determine the
extent of loop pipelining.  While doing the pipelining, one can specify
two parameters as follows
\begin{verbatim}
  $dopipeline $depth 8 $buffering 2
    ...
  $while ....
\end{verbatim}
This specifies that up to 8 iterations of the loops will be kept alive
in hardware, and the amount of buffering per operation will be kept to
at least 2 (or any specified integer).  Further the buffering specification implies that at most
2 versions of the same operations will be kept in flight across multiple
loop iterations.

Additionally, it is possible to specify that the loop-pipelining
be done to its extreme possibility, that is, to the maximum possible
rate that can be achieved.
\begin{verbatim}
  $dopipeline $depth 8 $buffering 2
  $fullrate // specify that extreme pipelining 
	    // should be attempted.
    ...
  $while ....
\end{verbatim}
When the full-rate is specified, the generated circuit will
be aggressively implemented to obtain a 1-cycle loop initiation
latency.  This may lead to long combinational paths, which can
be controlled by using double buffering.

Note that it is always possible to describe
a do-while loop using a branch-block, and this is what should be done
if loop-pipelining is not desired.

Note that the pipeline depth and buffering can be
specified as parameters or parameter expressions.

To summarize, an \Aa program is constructed as a collection of modules,
each of which is a sequence of statements.  The use of series,
parallel, fork and branch block
statements enables the programmer to describe a highly concurrent
structured system with complex branching behaviour.  
The resulting control flow structure is a
petri-net with provable liveness and safety properties \cite{ref:SameerPhD}.

\section{Scoping Rules (Deprecated!) } \label{sec:Scopes}

An \Aa program is made of modules which in turn contain statements
and so on.  The program thus has a hierarchy of scopes 
(except for the program, each scope is delimited by \{ and \}) with each
scope being contained in another (except for the program itself,
which is not contained in any scope).

The rules for scoping are as follows:
\begin{enumerate}
\item A declared variable defined in a scope is visible
in all descendent scopes. 
\item A reference to a variable $b$ in a scope X is resolved by checking
whether the variable is defined in that scope, and if not found there,
by checking in the scope that contains the scope X, and so on.
\item A scope can read from variables that are defined in ancestor scopes.
\item A scope can only write to one of the following:
\begin{itemize}
\item an implicit variable defined in the scope.
\item a storage or pipe variable defined in the scope or an ancestor
of the scope.
\item an output argument of a module of which the scope is a descendant.
In this case, there can be at most one statement in the entire module
which writes to this output argument.
\end{itemize}
\end{enumerate}

If, from within a scope, we wish to read the value of
a variable defined in a child scope, then the child scope
must export the value of the variable so that the parent
scope can access it.

\section{Types} \label{sec:Types}

Types in \Aa can be either scalar types or composite types.

Scalar types can be one of 
\begin{itemize}
\item Unsigned integers:  An unsigned integer type
has a width parameter and is specified as 
\begin{verbatim}
$uint<width>
\end{verbatim}
The width can be any positive integer (or a parameter
expression that evaluated to a positive integer).
Values corresponding to this type are to be
viewed as unsigned integers represented by 
a binary sequence of the specified width.
\item Signed integers:  A signed integer type
has a width parameter and is specified as 
\begin{verbatim}
$int<width>
\end{verbatim}
The width parameter can be any positive number.
Values corresponding to this type are to be
viewed as integers maintained in the
two-s complement form  by 
a binary sequence of the specified width.

\item Pointers:  A pointer is an unsigned
integer with a default pointer width
(set to 32 for now), which specifies the
type of object to which it points.
For example
\begin{verbatim}
$pointer< $uint<32> > 
\end{verbatim}
is a pointer which refers to a storage
object of type \begin{verbatim}$uint<32>\end{verbatim}
\item Floats: A float is parametrized by
two integers, the width of the exponent,
and the width of the mantissa.  
The specification is
\begin{verbatim}
$float<exponent,mantissa>
\end{verbatim} %$
where the exponent and mantissa must be positive
integers (or parameter expressions that evaluate
to positive integers).  The float is represented by 
a word with $exponent+mantissa+1$ bits
(with the additional bit needed for the sign).
The standard IEEE 754 float and double
precision representations correspond
to
\begin{verbatim}
$float<8,23> 
\end{verbatim}
and
\begin{verbatim}
$float<11,52> 
\end{verbatim}
respectively.  Currently, these are the
only float types that are supported.
\end{itemize}

Composite types in \Aa can be either
array types or record types.
\begin{itemize}
\item 
Array types in \Aa have the form
\begin{verbatim}
$array [d1][d2]...[dn] $of <element-type-spec>
\end{verbatim} %$
The values $ d1,d2, \ldots dn$ must
be positive integers, and element-type-spec
must refer to a type.
For example, 
\begin{verbatim}
$array [10][10] of $array [10] $of $uint<32>
\end{verbatim}
is a two-dimensional array type whose
elements are one dimensional arrays of 32-bit
unsigned integers.
\item
Record types in \Aa have the form
\begin{verbatim}
$record <type-1> <type-2> ... <type-n>
\end{verbatim}
An element of such a record type is
an aggregate whose first element is of type
type-1, second element is of type type-2 and so on.
For example:
\begin{verbatim}
$record <$uint<32> > <$array [10] $of $uint<32> > 
\end{verbatim}
\item Named record types are used to avoid the circular
reference problem (for example, when a record has a pointer to
itself).
\begin{verbatim}
$record [myrec] <$uint<32> >  <$pointer<myrec> >
\end{verbatim}
defines a record type with name myrec, one of whose
fields is a pointer to myrec.
\end{itemize}

\subsection{The bit-level layout of a Record-type}

Consider a record type:
\begin{verbatim}
$record [myrec] <$uint<8> >  < $uint<16> >
\end{verbatim}
which has an 8-bit field and a 16-bit field.  The
record type when implemented in hardware will
use 24 bits organized as follows
\begin{verbatim}
[23:8]                [7:0]
second-field          first-field
   16bit                8bit
\end{verbatim}

A cast from the record type to an integer type
will be consistent with this bit layout.
For example
\begin{verbatim}
// concatenate fields last-field to first-field.
r := ($cast (myrec) ($concat u16 u8))

//
// The cast from the record gives the 
// last field as the left-most.
// w[23:8] will be field 2, 
// w[7:0]  will be field 1.
w := ($bitcast ($uint<24>) r) 
\end{verbatim}

Note that an assignment to an SSA variable
with record type which writes only to
a part of a record is not permitted.
That is
\begin{verbatim}
r [0] := ....
\end{verbatim}
is not permitted if $r$ is an SSA variable
with a record type.


\section{Expressions} \label{sec:Expressions}


Expressions in \Aa fall into the following classes
\begin{itemize}
\item Constant literal references.
\item Simple object references.
\item Indexed object references.
\item Pointer de-reference expressions.
\item Address-of expressions.
\item Unary expressions.
\item Useful Unary logical expressions.
\item Slice expressions.
\item Bitmap (bit permutation) expressions.
\item Binary expressions.
\item Ternary expressions.
\item Zero, One expressions.
\item Funcion call expressions.
\end{itemize}

\subsection{Constant literal references} 

Constants can be specified in one of many
ways, depending on their type.
\begin{itemize}
\item Integers can be specified in their
decimal form, as for example 
\begin{verbatim}
23
-8
\end{verbatim}
or in binary form, as for example
\begin{verbatim}
_b10111
\end{verbatim}
When specified in binary form, the twos-complement
value of the integer being specified should be
used.
\item Floats are specified in the exponentiated
form
\begin{verbatim}
_f2.3000e+10
_f-1.354e+10
\end{verbatim}
where the mantissa has to have exactly one digit
to the left of the decimal point.
\item Composite constants are specified
as a space separated list of values.
\begin{verbatim}
( 12 32 43 10)
( (1 5) (2 8) (9 100) )
\end{verbatim}
etc.  The elements are listed in 
row major form.  Thus a[2][2] is
listed as
\begin{verbatim}
a[0][0] a[0][1] a[1][0] a[1][1]
\end{verbatim}
\item Parameters can be used as simple identifiers.
These are converted to integers (whose width as a uint
is unknown) provided they are defined at the point
of reference.
\end{itemize}

\subsection{Simple object references} 

References to an object have the form
\begin{verbatim}
<scope-specifier>:<object-specifier>
\end{verbatim}
The scope specifier can either specify a
parent scope of the scope in which the expression appears,
or a child scope of the scope in which the 
expression appears (as described in Section \ref{sec:Scopes}).  
The scope-specifier can be omitted
if the reference is to be resolved starting from the same scope
as the expression.
For example:
\begin{verbatim}
../:a
\end{verbatim}

\subsection{Indexed object references}

These have the form
\begin{verbatim}
<scope-specifier>:<root-object-specifier>[i1][i2]...[im]
\end{verbatim}
The scope and root-object-specifier are interpreted in the
same manner as before.  The indices $i1,i2, \ldots im$
must be non-negative integers.   The 
object-specifier must be one of
\begin{itemize}
\item A storage object whose type is composite.  For
example, if $a$ is a storage object whose
type is a two-dimensional composite type, then 
\begin{verbatim}
a[0][1]
\end{verbatim}
is interpreted in the usual manner.  Thus, when
the root-object-specifier is a declared storage
object, the indexed expression evaluates to an
element of the object.
\item A scalar object of type pointer.  For example if $ptr$ is a pointer
to an object of type $T$, then
\begin{verbatim}
ptr[1]
\end{verbatim}
is a pointer which will point to the adjacent object
of type T if we assume that ptr points to an array
of objects of type $T$.  This is similar to the following
evaluation in {\bf C}
\begin{verbatim}
int* ptr;     // ptr points to some int a[i].
ptr = ptr[1]  // ptr now points to a[i+1] 
\end{verbatim}
Now, if type T is a one-dimensional array type,
say
\begin{verbatim}
$array [10] of $uint<32>
\end{verbatim}
then the following expression makes sense
\begin{verbatim}
ptr[1][2]
\end{verbatim}
and is similar to the following evaluation in {\bf C}
\begin{verbatim}
int a[10][10];
ptr = &a[0]      // points to a[0] which is
                 // array of 10 integers
ptr = ptr[1][2]; // ptr points to a[1][2]
\end{verbatim} 
Thus, the evaluation of an indexed expression
whose root is a pointer evaluates to a
pointer of some element type.
\end{itemize}

\subsection{Pointer de-reference expressions}

If {\bf ptr} is a pointer to a scalar object,
then the expression 
\begin{verbatim}
->(ptr)
\end{verbatim}
refers to the value of the object pointed to
by {\bf ptr}.
Such an expression can occur {\bf only} as 
the target or source of a simple assignment statement.
For example
\begin{verbatim}
a := ->(ptr)
->(ptr) := (a+1)
\end{verbatim}

\subsection{Address-of expressions}

If {\bf a} is a declared {\bf storage} object,
then
\begin{verbatim}
@(a)
\end{verbatim}
is a pointer which points to {\bf a}.  Such 
an expression can occur {\bf only} as a source
of a simple assignment statement.
For example
\begin{verbatim}
ptr := @(a)
\end{verbatim}

\subsection{Unary expressions}

These can be of three types:
\begin{itemize}
\item 
The {\bf cast}
expression is of the form
\begin{verbatim}
($cast (<type-spec>)  <expression>)
\end{verbatim} %$
For example
\begin{verbatim}
($cast ($uint<10>) ../:a)
\end{verbatim}
The cast expression takes the value of the
specified expression and converts it to a value
of the specified type.  This is equivalent
to a type-cast in {\bf C}, as for example
in
\begin{verbatim}
float a;
int b = (int) a;
\end{verbatim}

\item 
The {\bf bitcast}
expression is of the form
\begin{verbatim}
($bitcast (<type-spec>)  <expression>)
\end{verbatim} %$
For example
\begin{verbatim}
($bitcast ($uint<10>) a)
\end{verbatim}
The bitcast expression takes takes the bits
corresponding to the value of the specified expression
and treats them as being of the specified cast type.
This is similar to the following in {\bf C}
\begin{verbatim}
float a;
int b = *((int*) &a);
\end{verbatim}
The destination type need not
be the same size as the source type (higher
order bits are truncated or padded with 0
as necessary).
\item 
The {\bf bit-wise complement} expression is of the form
\begin{verbatim}
( ~ <expression> )
\end{verbatim}
The symbol for the complement is the same
as the one used in the C programming language,
and the evaluation of the expression proceeds in the
usual way.
\end{itemize}

The parentheses around a unary expression are
{\bf required}.

\subsection{Useful Unary Logical expressions}

Some very useful logical building blocks are decoders,
encoders and bit-reduction operators.

\begin{itemize}
\item The unary expression
\begin{verbatim}
($encode x)
\end{verbatim}
expresses the encoded version of $x$ (produces a \$uint 
whose length is $\log{length(x)}$).  It operates only on \$uint types,
and produces an encoding of $x$ under the assumption that only
one of the bits in $x$ is $1$.
\item The unary expression 
\begin{verbatim}
($p_encode x)
\end{verbatim}
expresses the priority-encoded version of $x$ (produces a \$uint which
whose length is $length(x)$).  It operates only on \$uint types,
and identifies the highest bit position of $x$ which is $1$. For example
if $x$ is $01010$, then the expression will evaluate to $01000$.
\item The unary expressions
\begin{verbatim}
($bitreduce | x)
($bitreduce & x)
($bitreduce ^ x)
\end{verbatim}
produce the reduced single-bit version of $x$ with the specified operation.
For example, the bit-reduced OR is the OR of all the bits of $x$.
\end{itemize}

\subsection{Slice expressions}

Slice expressions can be used to extract a contiguous
bit-field from a value.  They have the
following syntax:
\begin{verbatim}
LPAREN $slice <expression> <high-index> <low-index> RPAREN
\end{verbatim}
where high-index and low-index are constant non-negative
integers (or parameter expressions that evaluate to
non-negative integers).  The result of executing the expression is
an unsigned integer whose width is $(high-index - low-index)+1$.
The value produced by expression may be of any type, but
for the slicing, it is flattened in the natural manner
(see the notes about aggregate types).  All bit-vectors
are assumed to indexed as $HIGH$ dowto $LOW$.

For example
\begin{verbatim}
( $slice ($bitcast ($uint<16>) _h1234) 8 4) = _h3
\end{verbatim}

\subsection{Bitmap expressions}

These expressions can be used to express bit permutations
in a word.  The syntax is as follows
\begin{verbatim}
LPAREN $bitmap <expression> ( <from-index> <to-index> )+ RPAREN
\end{verbatim}
The flattened bit-vector value of expression is permuted according
to the information provided by the $(from,to)$ pairs (result(to) = source(from)).

For example, 
\begin{verbatim}
// X has type $uint<4>
( $bitmap ($bitcast X) 0 3 1 2 2 1 3 0 ) = rX
\end{verbatim}
implements
\begin{verbatim}
rX[3] <- X[0], rX[1] <- X[2], 
   rX[2] <- X[1], rX[0] <- X[3]
\end{verbatim}
and
\begin{verbatim}
// X has type $uint<4>
( $bitmap ($bitcast X) 0 3 3 0) = rX
\end{verbatim}
implements (not that unmapped indices
are left undisturbed)
\begin{verbatim}
rX[3] <- X[0], rX[1] <- X[1], 
   rX[2] <- X[2], rX[3] <- X[0]
\end{verbatim}



\subsection{Binary expressions}

These are of the
form
\begin{verbatim}
(<expression> <operation-id>  <expression>)
\end{verbatim}
The following binary operations are supported
\begin{verbatim}
// arithmetic operators
PLUS              + 
MINUS             - 
MUL               * 
DIV               / 
SHL               <<
SHR               >> 
ROL               <o<
ROR               >o> 

// bit-wise logical operators
NOT               ~     
OR                |     
AND               &    
XOR               ^   
NOR               ~|     
NAND              ~&    
XNOR              ~^   

// comparison operators
EQUAL             ==
NOTEQUAL          !=
LESS              < 
LESSEQUAL         <=
GREATER           > 
GREATEREQUAL      >=

// concatenation operator
CONCATENATION     &&
     c = (a && b) means that the bits of
     a and b are concatenated to produce
     the bits of c.  a,b must be of type
     $uint<>

// bit-select operator
BITSELECT         []
    c = (a [] i) means that c gets the
    value of the bit of a with index i 
    (index 0 is the least significant bit)
\end{verbatim}
The evaluation of a binary expression proceeds in
the usual way.  Note that when specifying an 
expression, you {\bf must} use parentheses around
each expression.

\subsection{Ternary expressions}

There is only one
form for the ternary expression.
\begin{verbatim}
( $mux <test-expression>  <true-expression> <false-expression> )
\end{verbatim}%$
The test-expression is evaluated, and if true, the true-expression
is evaluated, and if false, the false-expression is evaluated.
Note the parentheses delimiting the expression.
For example
\begin{verbatim}
($mux a (b+1) (c+d))
\end{verbatim}

\subsection{Zero, One expressions}

For convenience, the following expressions represent
a zero and one value with the specified uint type:
\begin{verbatim}
$zero<width>
$one<width>
\end{verbatim}

The following expression 
\begin{verbatim}
$zero<16>
\end{verbatim}
expands to
\begin{verbatim}
($bitcast ($uint<16>) 0)
\end{verbatim}
and the  following expression
\begin{verbatim}
$one<16>
\end{verbatim}
expands to
\begin{verbatim}
($bitcast ($uint<16>) 1)
\end{verbatim}

\subsection{Function call expressions}

When a module is declared with only a single
output argument, then it can be ``called'' in
another way, using a function call expression.

For example
\begin{verbatim}
$module [add8] $in (X Y: $uint<8>) 
    $out(Z: $uint<8>)
$is
{
  Y := (X + 1)
}
\end{verbatim}

can be invoked in an expression as
\begin{verbatim}
P := ($call add8 (U V))
\end{verbatim}
for convenience.

\section{Synthetic instructions}

For convenience, there are some synthetic operations which
you can use to simplify coding an Aa program.  These
are listed below
\begin{itemize}
\item The \$reduce operation:
\begin{verbatim}
($reduce |  a  b  c)   
    (note: this is the same as  ((a+b)+c))
\end{verbatim}
Any associative operation may be used instead
of the or (add, mul, xor, and).
\item The \$concat operation:  This is the
reverse of a \$split.  
\begin{verbatim}
Y := ($concat a8 b8 c4 d4 e4 f4)
  (note: Y := (a8 && (b8 && (c4 && d4 ....))
\end{verbatim}
\item The \$excmux operations:  A multiplexor
whose selects are expected to be mutually exclusive.
\begin{verbatim}
Y := ($excmux s0 X0 s1 X1 s2 X2)
\end{verbatim}
This is equivalent to 
\begin{verbatim}
Y := ($reduce |
           ($mux s0 X0 0)
           ($mux s1 X1 0)
           ($mux s2 X2 0))
\end{verbatim}
Note that if all of s0,s1,s2 are 0, then
Y is assigned to 0.
\item The \$prioritymux operations:  A multiplexor
whose selects may not be mutually exclusive.
\begin{verbatim}
Y := ($prioritymux s0 X0 s1 X1 s2 X2
                $default 1)
\end{verbatim}
This is equivalent to 
\begin{verbatim}
Y := ($mux s0 X0
           ($mux s1 X1
                $mux s2 X2 1))
\end{verbatim}
\end{itemize}


\section{Specifying buffering for expressions}

By default, the result of each expression may be
buffered by the AHIR compilers.  The default amount of
buffering is $1$.  If you wish to specify more buffering, 
say $2$ units, then we add 
\begin{verbatim}
$buffering 2
\end{verbatim}
after the expression.

For example
\begin{verbatim}
( A $buffering 2  + (B + C) $buffering 3) $buffering 2
\end{verbatim}
means that the expression $A$ has buffering $2$,
the expression $(B+C)$ has buffering $3$ and the
overall expression $(A + (B+C))$ has buffering $2$.

\section{Parameter Expressions} \label{sec:ParamExprs}

Parameters are like constants, but have an implicit
integer types.  They are to be used in lieu of
constants in order to provide a measure of configurability
to the Aa program, as well as to improve readability of
the code. 

Pararmeters can be combined in expressions in the
much the same way as other objects.  The only difference
is that the delimitations is done using curly braces
instead of parenthesis, for example
\begin{verbatim}
{ a + {b + c} }
\end{verbatim}
Here, $a,b,c$ must be parameters, and the expression
is evaluated as soon as it is encountered and replaced
by its equivalent integer value.

All operations which are relevant for integers
are supported (including the ternary operation).


\section{Storage variables and Memory Spaces}

An \Aa program can contain declarations to storage objects.  These
storage objects are grouped into memory spaces using
the following rule: two storage objects must be in the same
memory space if there is a de-referenced pointer in the
program which can point to either of these two storage objects.

To understand this concept, consider the following
example
\begin{verbatim}
$module [foo] 
  $in (a: $uint<32>)
  $out (b: $uint<32>) 
$is
{
   $storage u: $uint<32>
   $storage v: $uint<32>
   $storage w: $uint<32>
   $storage ptr: $pointer< $uint<32> >
   w := a
   ptr := @(u)
   ->(ptr) := w
   ptr := @(v)
   ->ptr := u
   b := u
}
\end{verbatim}
Now consider the storage variable {\bf ptr}, which can hold a value which
is a pointer to either {\bf u} or a pointer to {\bf v}.  Thus,
{\bf u} and {\bf v} must belong to the same memory space.
However, {\bf w} can sit in a memory space by itself.  The
store accesses implied by the $->(ptr)$ will point to the
memory space which contains {\bf u} and {\bf v}.


\subsection{Pointers from ``outside´´? }

What should we do in the following case?
\begin{verbatim}
$module [foo]
   $in (a : $uint<32>)
   $out (b: $uint<32>)
$is
{
   $storage u: $uint<32> 
   $storage ptr: $uint<32>
   ptr := ($bitcast ($pointer<$uint<32> >) a)
   tmp := ->(ptr)
   ptr := @(u)
   ->(ptr) := tmp
   b := u
}
\end{verbatim}
In this case, {\bf ptr} takes the value of $a$,
and as a pointer, it must point to 
an {\bf external} object.  Since ptr can 
point to this external object and also to {\bf u},
the external object and {\bf u} must be kept in
the same memory space.  In this case, there
are two possible solutions: either the external
object needs
to be made internal, and moved {\bf inside} the system,
or, the object {\bf u} must be moved outside the system
and be made part of the outside world.
This is done by the {\bf AaLinkExtMem} utility
which is described in a separate document.


\section{Module classes: pipeline, volatile, operator,  macro, foreign }

By default, each distinct module in an \Aa program
is eventually implemented as a separate VHDL entity
by downstream AhirV2 tools (though downstream
tools are free to instantiate multiple
copies of this entity).  

However, in order to give the \Aa programmer
more flexibility,  a module in \Aa may be marked
as belonging to a particular class.  These
are described below.

\subsection{Pipelined Modules}

A module is marked as a pipeline-module if its
hardware implementation is to be converted into 
a pipeline.  This allows efficient use of the module
resources.

\begin{verbatim}
$pipeline $module [foo] $in (...) $out (...) $is
{
...
}
\end{verbatim}

A pipeline module {\bf must} have {\bf at least} one input
and one output argument.  Further, at least one input argument
must actually be sampled inside the module, and one output argument
must actually be updated inside the module.

Pipeline modules can have several parameters as follows:
\begin{verbatim}
$pipeline ($depth <integer>)? ($buffering <integer>)? ($fullrate)?
        $module [foo] $in (...) $out (...) $is
\end{verbatim}
The pipeline parameters are similar to the {\bf \$dopipeline} 
construct.

\subsection{Deterministic Pipelined Modules}

In certain situations, we are sure that all operations inside
a module are deterministic, that is, we know that they take
a fixed amount of time.  Examples of such operations are 
addition, subtraction etc. which are mapped to unshared
operators.  Examples of operations which are not deterministic
are pipe accesses and accesses to shared memory.

If we are sure that all operations are deterministic, then
we can add a qualifier to the pipelined module.  For instance
\begin{verbatim}
$pipeline $depth 3 $deterministic $operator
        $module [foo] $in (A B: $uint<8>) $out (C: $uint<8>) $is
{
   U := A
   V := (U + B)
   W := (V + A)
   C  := (W + B)
}
\end{verbatim}
This module will then eventually be implemented in VHDL
using much simpler control logic.

Pipelined modules have the following restrictions:
\begin{itemize}
\item Their internal structure is that of an
operator module (Section \ref{sec:OperatorModules}).
\item They can not access memory.
\item They can not access pipes.
\item The only write-after-read sequences permitted
are of an accumulation type, for example
\begin{verbatim}
a := (a + 1)
\end{verbatim}
\item They can call other modules only if the called
modules are either volatile (Section \ref{sec:VolatileModules}) or deterministic pipelines.
\end{itemize}

In many cases, the core computation is completely
deterministic, and we can save considerable hardware
by collecting it into a deterministic pipeline.

\subsection{Operator Modules} \label{sec:OperatorModules}

A module is marked as an operator-module if it
is to be substituted at every point where it
is called (thus, multiple instances of the module
will be generated).
This allows low latency access to the module
functionality in hardware.

\begin{verbatim}
$operator $module [foo] $in (...) $out (...) $is
{
...
}
\end{verbatim}

An operator module {\bf must} have {\bf at least} one input
and one output argument.  Further, at least one input argument
must actually be sampled inside the module, and one output argument
must actually be updated inside the module.

An operator module may also be marked as pipelined.
\begin{verbatim}
$pipeline $operator $module [foo] $in (..) $out (..)
\end{verbatim}

An operator module is not allowed to access pipes from within.
Inside an operator module, function calls can be made only
to operator/volatile modules.

\subsection{Volatile Modules} \label{sec:VolatileModules}

A module is marked as a volatile-module if 
\begin{itemize}
\item Its hardware implementation is to be 
a combinational (memory-less) circuit.
\item It is to be substituted at every point where it
is called (thus, multiple instances of the module
will be generated).
\end{itemize}
This allows low level implementation control
to the programmer.

\begin{verbatim}
$volatile $module [foo] $in (...) $out (...) $is
{
...
}
\end{verbatim}

A volatile module cannot make any memory accesses or 
reads/writes to pipes.  Inside a volatile module, 
a function call must be to volatile modules only.

\subsection{Opaque Modules} \label{sec:Opaque}

The {\bf Aa} compiler normally looks inside module
descriptions to identify load/store or pipe access
dependencies.  If you mark a module as opaque, then
the calling module will ignore dependencies inside
this module while generating the control path.

An example of an opaque module:
\begin{verbatim}
$opaque $module [foo] $in (a: $uint<9>)
   $out (b: $uint<8>) $is
{
    // out_pipe is a pipe.
    out_pipe := a

    b := in_pipe
}
\end{verbatim}



\subsection{Macro Modules}

A module defined as a macro (described below)
is directly substituted at the point of a call
to it.  That is, all references to input and
output arguments
are replaced by references to the corresponding
expression passed to the called function.  
The semantics are equivalent to a MACRO instantiation
in programming languages such as C/C++.

For example:
\begin{verbatim}
$macro $module [shift] $in (a: $uint<32>) 
    $out (c: $uint<32>) $is
{
    c := a 
}  

$pipe inpipe: $uint<32>
$pipe midpipe: $uint<32>
$pipe outpipe: $uint<32>

$module [shift_check] $in () 
    $out () $is
{
    $call shift (inpipe) (midpipe)
    $call shift (midpipe) (outpipe)
}

\end{verbatim}
is equivalent to 
\begin{verbatim}
$pipe  inpipe : $uint<32>  $depth 1 
$pipe  midpipe : $uint<32>  $depth 1 
$pipe  outpipe : $uint<32>  $depth 1 
$module [shift_check]
$in ()
$out ()
$is
{
    midpipe := inpipe
    outpipe := midpipe
}
\end{verbatim}
The two calls to shift are replaced by
the body of the shift module with input/output arguments
replaced by the expressions passed to them
at the point of the call.

Since it is possible to pass a pipe as an 
argument to a call, a macro-module is permitted
to violate the rule that there should
be at most one write to an interface object
within a module.

Macro modules should consist of only assignment
statements and call statements.  There should
be no object declarations inside a macro module.

\section{Foreign Modules}


A module can be marked as foreign by using the

\$foreign keyword.
\begin{verbatim}
$foreign $ module [GetValue]
	$in (ptr $pointer<32>)
	$out (val $uint<32>)
\end{verbatim}

The \Aa compiler then considers that the module GetValue
is defined ``elsewhere'' and does not try to link to it
directly.  This linking is done outside by other tools which
use the results of the \Aa compilation process.

\section{Gated clocks}

	Gated clocks can be declared and controlled within the Aa
	language framework.   There are two control scenarios which
	are supported.
\begin{itemize}
\item  Automatic mode:
	   the gated clock can be attached to a module, and is
	  enabled whenever the module is activated (by the
	  start\_req/start\_ack pair), and disabled when the
	  module is no longer active, i.e., it has no further
	  jobs in progress inside it.
\item Explicit mode:
	   the gated clock enable signal is generated from within
	   some logic described in Aa.
\end{itemize}

\subsection{Creating and using an explicitly controlled gated clock}

	To create an explicit gated clock, we need to declare an enable signal
	and a gated clock to which it is matched.  For example
\begin{verbatim}
// signal declaration of an enable.
$pipe  data_1_clock_enable: $uint<1> $signal
// gated clock attached to enable.
$gated_clock  data_1_clock data_1_clock_enable
\end{verbatim}

	Now the declared gated clock can be applied to
	a module foo by the statement
\begin{verbatim}
	$use_gated_clock foo  data_1_clock
\end{verbatim}
 	It is the responsibility of the programmer
	to control the enable signal (data\_1\_clock\_enable above).
	This enable signal will control the gated clock data\_1\_clock
	which is used by the module foo.


\subsection{Declaring and using automatic gated clocks}

	In this case, all we need to declare is that 
	a module ``bar'' will run on a gated clock which
	is enabled when the module is working on an active job
	and disabled otherwise.  This is done by the
	statement
\begin{verbatim}
$use_gated_clock bar
\end{verbatim}



\section{Examples}


Here is a very simple program
\begin{verbatim}
// an array of 32-bit unsigned integers.
$storage mem: $array<1024> of $uint<32> 
$module [sel_mod]
   $in (a:$uint<32> b:$uint<10>)
   $out (c:$uint<32>)
$is
{
   t := (mem[b] + a)
   mem[b] := t
   c := t
}
\end{verbatim}
This consists of a single module, which accumulates
a value into an array position.

An example which is a little bit more complicated:
\begin{verbatim}
// an array of 32-bit unsigned integers.
$storage mem:$array[1024] $of $uint<32>   

// module returns the sum of mem[I] from
// I=low to I=high
$module [sum_mod]
    $in (low:$uint<10> high:$uint<10>)
    $out (sum:$uint<32>)
$is
{
   d := (high-low)  
   mp := ((high-low)/2)

   $branchblock[trivcheck]
    {
       // d from parent scope
       $if (d > 0) $then  
           // do two summations in parallel
           // parallel summations
           $parallelblock[parsum]
           {
               $branchblock[sb1]{
                    $storage  I:$uint<10>
                    $merge $entry loopback
                       $phi s := 0 $on $entry  s1 $on loopback
                    $endmerge
                    $if (I < mp) $then
                       I := (I+1)
                       s1 := ($mux (I == 0)  0 (s + mem[I]))
                       $place [loopback]
                    $endif
               } (s => sb1_s)
               $branchblock[sb2]{
                    $storage  J:$uint<10>
                    J := (mp + 1)
                    $merge $entry loopback
                       $phi s := 0 $on $entry s1 $on loopback
                    $endmerge
                    $if (J < high) $then
                         J := (J+1)
                         s1 := ($mux (J == (mp+1))  0 (s + mem[J]))
                         $place [loopback]
                    $endif
               } (s => sb2_s)
           }(sb1_s => sb1_s sb2_s => sb2_s)
 
           // combine results from parallel statement above
           snontriv := (sb1_s  + sb2_s)
           $place [nontrivsum]
      $else

           // summation is trivial 
           striv := mem[low]
           $place [trivsum]
      $endif
      $merge nontrivsum trivsum
         // which sum do you pick? depends on which path was taken
         $phi sum := snontriv $on nontrivsum striv $on trivsum
      $endmerge
    }
}
\end{verbatim} 
This example describes an algorithm which computes the sum of
a section of an array by dividing the problem into two partial
summations. 

\section{Syntax} \label{sec:Syntax}

The syntax for \Aa follows the following
principles
\begin{itemize}
\item All keywords begin with the \$ sign.
\item The region between \{ and \} defines a new scope.
\item Statements are space separated (no semicolons at all).
\item Expressions are fully parenthitized.  Thus
$(a + b)$ is a legal expression, but $a+b$ is not.
\end{itemize}

The parser is implemented using 
an LL(k) parser (written as rules to be parsed by antlr2 \cite{ref:antlr2}).
The grammar for the parser is (using the EBNF notation) given in 
the html file {\bf AaParser.html} which is part of this distribution. 
The set of tokens recognized by the lexical analyzer (or lexer).
is available in the html file {\bf AaLexer.html}.

\begin{thebibliography}{99}
\bibitem{ref:SameerPhD}
Sameer D. Sahasrabuddhe,
``A competitive pathway from high-level programs to hardware,''
Ph.D. thesis, IIT Bombay, 2009.

\bibitem{ref:antlr2}
http://www.antlr2.org.
\end{thebibliography}

\end{document}
